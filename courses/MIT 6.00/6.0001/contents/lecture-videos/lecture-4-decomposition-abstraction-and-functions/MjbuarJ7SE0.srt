1
00:00:00,790 --> 00:00:03,190
The following content is
provided under a Creative

2
00:00:03,190 --> 00:00:04,730
Commons license.

3
00:00:04,730 --> 00:00:07,030
Your support will help
MIT OpenCourseWare

4
00:00:07,030 --> 00:00:11,390
continue to offer high quality
educational resources for free.

5
00:00:11,390 --> 00:00:13,990
To make a donation or
view additional materials

6
00:00:13,990 --> 00:00:17,880
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:17,880 --> 00:00:18,840
at ocw.mit.edu.

8
00:00:31,056 --> 00:00:34,080
PROFESSOR: All right
everyone let's get started.

9
00:00:34,080 --> 00:00:37,290
All right good afternoon on
this rainy, rainy sad afternoon.

10
00:00:37,290 --> 00:00:39,900
So-- I'm glad we're
inside though-- all right

11
00:00:39,900 --> 00:00:44,630
so Lecture 4 of 6.0001 in 600.

12
00:00:44,630 --> 00:00:46,850
Quick, quick recap of
what we did last time.

13
00:00:46,850 --> 00:00:50,420
So last time we did a little
bit more string manipulations,

14
00:00:50,420 --> 00:00:53,630
and then we saw how you can
use for loops over strings

15
00:00:53,630 --> 00:00:54,380
directly.

16
00:00:54,380 --> 00:00:57,310
So instead of having for
loops that iterate over

17
00:00:57,310 --> 00:01:00,050
range-- so 0, 1, 2,
3, 4, and so on--

18
00:01:00,050 --> 00:01:02,600
you saw that it was more
powerful to sometimes use

19
00:01:02,600 --> 00:01:08,351
for loops that iterate over
string objects directly.

20
00:01:08,351 --> 00:01:10,100
So that was the first
half of the lecture.

21
00:01:10,100 --> 00:01:13,040
In the second half, we started
looking at different ways

22
00:01:13,040 --> 00:01:18,920
that you can implement the
different implementations

23
00:01:18,920 --> 00:01:19,820
to the same problem.

24
00:01:19,820 --> 00:01:22,880
So we saw the problem of
finding the cube root,

25
00:01:22,880 --> 00:01:25,970
and we saw some implementations.

26
00:01:25,970 --> 00:01:28,160
We saw the Guess
and Check method,

27
00:01:28,160 --> 00:01:30,170
and the approximation method.

28
00:01:30,170 --> 00:01:32,270
And then we looked
at what I thought

29
00:01:32,270 --> 00:01:35,334
was the most powerful method,
which was the bisection method.

30
00:01:35,334 --> 00:01:37,250
And this one, if you
remember, I played a game

31
00:01:37,250 --> 00:01:39,680
with someone in the
audience where I guessed

32
00:01:39,680 --> 00:01:42,170
a number between 0 and 100.

33
00:01:42,170 --> 00:01:44,660
And we saw that I was able
to guess that number really,

34
00:01:44,660 --> 00:01:47,120
really quickly using
the bisection method.

35
00:01:47,120 --> 00:01:48,754
And that's the
method that you're

36
00:01:48,754 --> 00:01:51,170
going to implement-- that you
are currently implementing--

37
00:01:51,170 --> 00:01:53,990
in your problem set.

38
00:01:53,990 --> 00:02:03,900
OK so today-- so that sort
of finishes introduction

39
00:02:03,900 --> 00:02:07,134
to some of the more basic
mechanisms in Python.

40
00:02:07,134 --> 00:02:08,759
And today we're going
to talk about how

41
00:02:08,759 --> 00:02:11,640
to structure your programs
such that you write

42
00:02:11,640 --> 00:02:15,660
nice, coherent code-- reusable
code-- by hiding away some

43
00:02:15,660 --> 00:02:17,867
of the details in your code.

44
00:02:17,867 --> 00:02:19,950
And to do that we're going
to look at these things

45
00:02:19,950 --> 00:02:22,860
called functions.

46
00:02:22,860 --> 00:02:25,450
All right so just
stepping back and sort

47
00:02:25,450 --> 00:02:28,870
of getting a high-level view of
how we write the code so far.

48
00:02:28,870 --> 00:02:32,440
So so far the way that
you've been writing code

49
00:02:32,440 --> 00:02:34,850
for your programs
is you open a file,

50
00:02:34,850 --> 00:02:37,760
you type some code to solve
a particular problem given,

51
00:02:37,760 --> 00:02:41,620
like in your problem
sets, each file

52
00:02:41,620 --> 00:02:45,680
contains some piece of code, you
have sequences of instructions

53
00:02:45,680 --> 00:02:49,040
that contain maybe assignments,
loops, conditionals,

54
00:02:49,040 --> 00:02:50,700
and so on and so on.

55
00:02:50,700 --> 00:02:54,350
But really you have one
file that contains each code

56
00:02:54,350 --> 00:02:58,190
and you write everything
in that particular file.

57
00:02:58,190 --> 00:03:01,035
But this is OK for
smaller problems

58
00:03:01,035 --> 00:03:02,660
that we've been seeing
so far, but when

59
00:03:02,660 --> 00:03:04,700
you're starting to write
large pieces of code

60
00:03:04,700 --> 00:03:07,520
it's going to get really
messy, really quickly.

61
00:03:07,520 --> 00:03:10,340
So think about if you
want to use a for loop

62
00:03:10,340 --> 00:03:12,754
in one part of
your code, and you

63
00:03:12,754 --> 00:03:14,420
find it useful to use
that same for loop

64
00:03:14,420 --> 00:03:16,700
in another part of your code.

65
00:03:16,700 --> 00:03:19,290
Some point in the future as
you're debugging your code,

66
00:03:19,290 --> 00:03:21,290
you might want to change
your original for loop,

67
00:03:21,290 --> 00:03:23,081
you have to figure out
all the other places

68
00:03:23,081 --> 00:03:27,020
where you've used that type
of for loop for example.

69
00:03:27,020 --> 00:03:30,440
So as you're scaling
your code, you'll

70
00:03:30,440 --> 00:03:32,985
find it harder to keep
track of these details.

71
00:03:32,985 --> 00:03:35,360
So this is where functions
will come into play in today's

72
00:03:35,360 --> 00:03:37,190
lecture-- will help you out.

73
00:03:40,490 --> 00:03:45,580
So if you want to be
considered a good programmer,

74
00:03:45,580 --> 00:03:49,420
a good programming style would
be to not necessarily add

75
00:03:49,420 --> 00:03:51,220
lots and lots of lines
of code, but really

76
00:03:51,220 --> 00:03:54,610
to add more functionality
to your programs.

77
00:03:54,610 --> 00:03:57,430
So how many different things--
how many different features--

78
00:03:57,430 --> 00:04:01,420
can your program do, rather
than how long can your code be.

79
00:04:01,420 --> 00:04:04,134
And that'll help you
later on look at your code

80
00:04:04,134 --> 00:04:05,550
if you need it for
a future class,

81
00:04:05,550 --> 00:04:07,841
and it'll help others if they
want to look at your code

82
00:04:07,841 --> 00:04:10,930
later on if they find it useful.

83
00:04:10,930 --> 00:04:13,930
So today we're introducing
this idea of functions.

84
00:04:13,930 --> 00:04:16,399
And functions are
mechanisms to achieve

85
00:04:16,399 --> 00:04:19,410
decomposition and abstraction.

86
00:04:19,410 --> 00:04:21,197
So these are two
key words here that

87
00:04:21,197 --> 00:04:22,780
are going to pop up
in today's lecture

88
00:04:22,780 --> 00:04:24,860
and also in future lectures.

89
00:04:24,860 --> 00:04:28,530
So before I introduce
decomposition and abstraction

90
00:04:28,530 --> 00:04:30,420
in the context of
functions, let's

91
00:04:30,420 --> 00:04:33,745
first take a look at just
sort of a real-life example.

92
00:04:33,745 --> 00:04:35,430
So let's take a projector.

93
00:04:35,430 --> 00:04:37,710
I'm using one right now.

94
00:04:37,710 --> 00:04:40,320
Quick show of hands.

95
00:04:40,320 --> 00:04:42,540
If I give you all of the
electronic components

96
00:04:42,540 --> 00:04:47,470
that are part of a projector--
resistors, a fan, a light bulb,

97
00:04:47,470 --> 00:04:51,330
a lens, the casing, all of
the different parts in it.

98
00:04:51,330 --> 00:04:57,430
Who here would be able
to build a projector?

99
00:04:57,430 --> 00:04:58,150
Do I see a hand?

100
00:04:58,150 --> 00:04:58,680
No?

101
00:04:58,680 --> 00:05:00,910
Ooh oh yeah nice!

102
00:05:00,910 --> 00:05:01,960
You can also lie.

103
00:05:01,960 --> 00:05:03,610
I won't know the difference.

104
00:05:03,610 --> 00:05:06,790
But if you can do that,
I'd be very impressed.

105
00:05:06,790 --> 00:05:10,300
All right so you can't really
put together a projector right?

106
00:05:10,300 --> 00:05:12,610
Another show of hands.

107
00:05:12,610 --> 00:05:15,526
If I gave you a projector
that's fully assembled

108
00:05:15,526 --> 00:05:17,150
and I gave you a
computer, for example,

109
00:05:17,150 --> 00:05:19,400
who would be able to maybe
figure out within let's say

110
00:05:19,400 --> 00:05:23,360
an hour how to make
them work together?

111
00:05:23,360 --> 00:05:25,730
Good, a fair bit of the class.

112
00:05:25,730 --> 00:05:26,790
That's perfect.

113
00:05:26,790 --> 00:05:29,930
That's exactly the answers
I was trying to get at here.

114
00:05:29,930 --> 00:05:34,630
So none of us really
know how a projector

115
00:05:34,630 --> 00:05:37,420
works-- the internals--
but a lot more of us

116
00:05:37,420 --> 00:05:40,720
know how to work a
projector, just given maybe

117
00:05:40,720 --> 00:05:45,160
a set of basic instructions
or just intuitively speaking.

118
00:05:45,160 --> 00:05:47,680
So you see the projector
as sort of a black box.

119
00:05:47,680 --> 00:05:51,270
You don't need to know how
it works in order to use it.

120
00:05:51,270 --> 00:05:55,150
You know maybe what inputs
it might take, what's it

121
00:05:55,150 --> 00:05:57,040
supposed to do at a high level.

122
00:05:57,040 --> 00:06:01,120
Take whatever's on my screen and
put it up on the large screen

123
00:06:01,120 --> 00:06:03,760
there, just magnify
it, but you don't

124
00:06:03,760 --> 00:06:06,980
know how it does it-- how
the components work together.

125
00:06:06,980 --> 00:06:09,050
So that's the idea
of abstraction.

126
00:06:09,050 --> 00:06:11,380
You don't need to know how
the projector works in order

127
00:06:11,380 --> 00:06:13,630
to use it.

128
00:06:13,630 --> 00:06:15,850
OK that's abstraction.

129
00:06:15,850 --> 00:06:19,150
The other half of that
was decomposition.

130
00:06:19,150 --> 00:06:22,750
So let's say that now,
given a projector,

131
00:06:22,750 --> 00:06:25,690
I want to project a very,
very large image down

132
00:06:25,690 --> 00:06:28,840
on a very large stage.

133
00:06:28,840 --> 00:06:31,690
For example, this is
from one of the Olympics.

134
00:06:31,690 --> 00:06:33,940
It's a stage of what,
like 10 football fields,

135
00:06:33,940 --> 00:06:35,340
something like that?

136
00:06:35,340 --> 00:06:36,090
Something massive.

137
00:06:36,090 --> 00:06:38,080
You could build one
projector that's

138
00:06:38,080 --> 00:06:39,760
able to project a
very large image,

139
00:06:39,760 --> 00:06:41,800
but that would be
really expensive

140
00:06:41,800 --> 00:06:43,920
and you'd have to build
this one projector that's

141
00:06:43,920 --> 00:06:47,432
used for this one time.

142
00:06:47,432 --> 00:06:48,890
So instead what
you could do is you

143
00:06:48,890 --> 00:06:52,850
can take a bunch of
smaller projectors

144
00:06:52,850 --> 00:06:56,785
and feed different inputs
to each one of them.

145
00:06:56,785 --> 00:06:58,410
And as you're feeding
different inputs,

146
00:06:58,410 --> 00:07:00,530
each one's going to
show a different output.

147
00:07:00,530 --> 00:07:01,850
And then you're going
to be able to have

148
00:07:01,850 --> 00:07:03,933
all of these different
projectors working together

149
00:07:03,933 --> 00:07:07,430
to solve this larger
problem of projecting

150
00:07:07,430 --> 00:07:11,920
this really cool image
on a very large stage.

151
00:07:11,920 --> 00:07:16,870
So that's the idea
of decomposition.

152
00:07:16,870 --> 00:07:21,970
You take the same projector,
feed it different inputs,

153
00:07:21,970 --> 00:07:24,010
it does the exact same
thing behind the scenes,

154
00:07:24,010 --> 00:07:25,593
but it will produce
a different output

155
00:07:25,593 --> 00:07:28,922
for each one of these
different inputs.

156
00:07:28,922 --> 00:07:31,130
So these different devices
are going to work together

157
00:07:31,130 --> 00:07:33,380
to achieve the same
common goal, and that's

158
00:07:33,380 --> 00:07:36,820
the idea of decomposition.

159
00:07:36,820 --> 00:07:40,950
So these is where I apply
to the problem of projecting

160
00:07:40,950 --> 00:07:43,320
large image, or a
projector in general,

161
00:07:43,320 --> 00:07:47,820
but we can apply these exact
same concepts to programming.

162
00:07:47,820 --> 00:07:51,180
So decomposition is
really just the problem

163
00:07:51,180 --> 00:07:53,230
of creating structure
in your code.

164
00:07:53,230 --> 00:07:55,890
In the projector example,
we have separate devices

165
00:07:55,890 --> 00:07:58,400
working together.

166
00:07:58,400 --> 00:08:01,410
In programming, to
achieve decomposition

167
00:08:01,410 --> 00:08:03,610
you're dividing your code
into smaller modules.

168
00:08:03,610 --> 00:08:05,550
These are going to
be self-contained,

169
00:08:05,550 --> 00:08:09,240
and you can think of them as
sort of little mini-programs.

170
00:08:09,240 --> 00:08:12,287
You feed in some input to
them, they do a little task,

171
00:08:12,287 --> 00:08:13,870
and then they give
you something back.

172
00:08:13,870 --> 00:08:15,660
They go off and do
their thing and then

173
00:08:15,660 --> 00:08:19,510
they give back a result.

174
00:08:19,510 --> 00:08:23,720
These modules can be used
to break up your code,

175
00:08:23,720 --> 00:08:26,670
and the important thing
is that they're reusable.

176
00:08:26,670 --> 00:08:28,880
So you write a module once--
a little piece of code

177
00:08:28,880 --> 00:08:33,128
that does something
once-- you debug it once,

178
00:08:33,128 --> 00:08:35,419
and then you can reuse it
many, many times in your code

179
00:08:35,419 --> 00:08:37,970
with different inputs.

180
00:08:37,970 --> 00:08:41,120
Benefit of this is it
keeps your code organized

181
00:08:41,120 --> 00:08:44,495
and it keeps your code coherent.

182
00:08:44,495 --> 00:08:47,960
So functions are going to be
used to achieve decomposition

183
00:08:47,960 --> 00:08:49,920
and to create
structure in our code.

184
00:08:49,920 --> 00:08:52,237
We're going to see functions
today in this lecture,

185
00:08:52,237 --> 00:08:54,320
and in a few weeks, you're
going to actually see--

186
00:08:54,320 --> 00:08:56,486
when we talk about object
oriented programming-- how

187
00:08:56,486 --> 00:08:59,600
you can achieve
decomposition with classes.

188
00:08:59,600 --> 00:09:02,510
And with classes you can
create your own object types

189
00:09:02,510 --> 00:09:03,682
like adding some floats.

190
00:09:03,682 --> 00:09:06,140
You can create your own object
types for whatever you want,

191
00:09:06,140 --> 00:09:08,630
but that's later.

192
00:09:08,630 --> 00:09:12,480
OK so decomposition is creating
structure in your code.

193
00:09:12,480 --> 00:09:15,630
And abstraction is the idea
of suppressing details.

194
00:09:15,630 --> 00:09:17,780
So in the projector example,
remember, abstraction

195
00:09:17,780 --> 00:09:20,450
was you didn't need to know
exactly how the projector

196
00:09:20,450 --> 00:09:21,850
worked in order to use it.

197
00:09:21,850 --> 00:09:24,500
And it's going to be the
same idea in programming.

198
00:09:24,500 --> 00:09:28,467
So once you write a piece of
code that does a little task,

199
00:09:28,467 --> 00:09:30,800
you don't need to rewrite
that piece of code many times.

200
00:09:30,800 --> 00:09:33,537
You've written it
once, and you write

201
00:09:33,537 --> 00:09:35,620
this thing called a function
specification for it,

202
00:09:35,620 --> 00:09:36,790
or a docstring.

203
00:09:36,790 --> 00:09:40,002
And this is a piece of
text that tells anyone

204
00:09:40,002 --> 00:09:42,460
else who would want to use it
in the future-- other people,

205
00:09:42,460 --> 00:09:46,270
maybe yourself-- it tells
them how to use this function.

206
00:09:46,270 --> 00:09:48,330
What inputs does it take?

207
00:09:48,330 --> 00:09:49,580
What's the type of the inputs?

208
00:09:49,580 --> 00:09:51,550
What is the function
supposed to do?

209
00:09:51,550 --> 00:09:54,800
And what is the output that
you're going to get out of it?

210
00:09:54,800 --> 00:09:57,050
So they don't need to know
exactly how you implemented

211
00:09:57,050 --> 00:09:57,710
the function.

212
00:09:57,710 --> 00:09:59,690
They just need to know
inputs, what it does,

213
00:09:59,690 --> 00:10:00,620
what's the output.

214
00:10:00,620 --> 00:10:04,360
Those three things.

215
00:10:04,360 --> 00:10:08,040
OK so these functions are
then reusable chunks of code.

216
00:10:08,040 --> 00:10:10,320
And we'll see in a few
examples in today's lecture

217
00:10:10,320 --> 00:10:15,424
how to write some and
how to call functions.

218
00:10:15,424 --> 00:10:17,090
And as we're going
through today's code,

219
00:10:17,090 --> 00:10:19,790
I want you to sort of
think about functions

220
00:10:19,790 --> 00:10:22,340
with two different hats on.

221
00:10:22,340 --> 00:10:26,150
The first hat is from someone
who's writing the function.

222
00:10:26,150 --> 00:10:27,650
So in the projector
example, someone

223
00:10:27,650 --> 00:10:29,510
had to build the
first projector.

224
00:10:29,510 --> 00:10:32,940
Someone had to know how to put
all these components together.

225
00:10:32,940 --> 00:10:35,490
So that's going to be
you writing a function,

226
00:10:35,490 --> 00:10:38,600
so you need to know how
to make the function work.

227
00:10:38,600 --> 00:10:41,720
And then the other hat
is you as someone--

228
00:10:41,720 --> 00:10:44,210
as a programmer-- who is
just using the function.

229
00:10:44,210 --> 00:10:47,180
You're assuming it's already
been implemented correctly,

230
00:10:47,180 --> 00:10:50,300
and now you're just
using it to do something.

231
00:10:54,680 --> 00:10:57,019
So these are some of the
function characteristics

232
00:10:57,019 --> 00:10:58,810
and we'll see an example
on the next slide.

233
00:10:58,810 --> 00:11:01,330
So a function's
going to have a name.

234
00:11:01,330 --> 00:11:02,752
You have to call it something.

235
00:11:02,752 --> 00:11:04,210
It's going to have
some parameters.

236
00:11:04,210 --> 00:11:06,040
These are the inputs
to the function.

237
00:11:06,040 --> 00:11:09,520
You can have 0 inputs or
as many as you'd like.

238
00:11:09,520 --> 00:11:11,590
Function should
have a docstring.

239
00:11:11,590 --> 00:11:13,257
This is how you
achieve abstraction.

240
00:11:13,257 --> 00:11:14,965
So it's optional, but
highly recommended,

241
00:11:14,965 --> 00:11:16,930
and this is how you
tell other people

242
00:11:16,930 --> 00:11:19,780
how to use your function.

243
00:11:19,780 --> 00:11:22,540
Function has a body, which
is the meat and potatoes

244
00:11:22,540 --> 00:11:24,760
of the function-- what it does.

245
00:11:24,760 --> 00:11:27,540
And a function's going
to return something.

246
00:11:27,540 --> 00:11:30,210
It computes its thing and
then it gives back-- spits

247
00:11:30,210 --> 00:11:32,360
back some answer.

248
00:11:32,360 --> 00:11:37,660
OK here's an example of
a function definition

249
00:11:37,660 --> 00:11:40,300
and a function call.

250
00:11:40,300 --> 00:11:42,970
Function definition is up here.

251
00:11:42,970 --> 00:11:46,600
I'll just draw it here.

252
00:11:46,600 --> 00:11:50,300
This is the function
definition up here.

253
00:11:50,300 --> 00:11:53,190
And this is the
function call down here.

254
00:11:53,190 --> 00:11:57,700
So remember, someone has
to write the function that

255
00:11:57,700 --> 00:11:58,910
does something to begin with.

256
00:11:58,910 --> 00:12:00,680
So this is how you
write the function.

257
00:12:00,680 --> 00:12:02,770
The first is
whoops-- the first is

258
00:12:02,770 --> 00:12:07,440
going to be this def keyword.

259
00:12:07,440 --> 00:12:10,180
And def stands for--
it tells Python

260
00:12:10,180 --> 00:12:13,760
I'm going to define a function.

261
00:12:13,760 --> 00:12:15,670
Next is the name
of the function.

262
00:12:15,670 --> 00:12:19,630
In this case, I'm calling
the function is_even.

263
00:12:19,630 --> 00:12:21,400
And the function
name should really

264
00:12:21,400 --> 00:12:23,200
be something descriptive.

265
00:12:23,200 --> 00:12:25,270
Whereas someone who is
just using this function

266
00:12:25,270 --> 00:12:27,340
or looking at it can
pretty much tell what

267
00:12:27,340 --> 00:12:31,716
it's supposed to do without
going a lot farther than that.

268
00:12:31,716 --> 00:12:33,090
They're just
looking at the name.

269
00:12:35,920 --> 00:12:39,280
And then in parentheses you give
it any parameters, also known

270
00:12:39,280 --> 00:12:40,450
as arguments.

271
00:12:40,450 --> 00:12:43,920
And these parameters are
the inputs to the function.

272
00:12:43,920 --> 00:12:44,957
And then you do colon.

273
00:12:48,160 --> 00:12:53,236
OK so this is the first line
of the function definition.

274
00:12:53,236 --> 00:12:54,610
And after this,
everything that's

275
00:12:54,610 --> 00:12:58,870
going to be part of the function
is going to be indented.

276
00:12:58,870 --> 00:13:01,096
The next part is going
to be the docstring,

277
00:13:01,096 --> 00:13:02,470
or the specification,
and this is

278
00:13:02,470 --> 00:13:07,210
how we achieve abstraction
using functions.

279
00:13:07,210 --> 00:13:10,481
Specification, or the docstring,
starts with triple quotes

280
00:13:10,481 --> 00:13:12,480
and ends with triple
quotes, and you can sort of

281
00:13:12,480 --> 00:13:15,430
think about this as
a multi-line comment.

282
00:13:15,430 --> 00:13:16,960
It's just going
to be text that's

283
00:13:16,960 --> 00:13:20,320
going to be visible to
whoever uses the function,

284
00:13:20,320 --> 00:13:23,140
and it should tell them
the following things: What

285
00:13:23,140 --> 00:13:25,460
are the inputs to the function?

286
00:13:25,460 --> 00:13:27,820
What is the function
supposed to do generally?

287
00:13:27,820 --> 00:13:30,550
And what is the function
going to give back

288
00:13:30,550 --> 00:13:31,718
to whoever called it?

289
00:13:35,550 --> 00:13:39,210
The next part is going to
be the body of the function.

290
00:13:39,210 --> 00:13:41,430
We'll talk about what's
inside it in the next slide.

291
00:13:44,170 --> 00:13:45,130
And that's it.

292
00:13:45,130 --> 00:13:47,880
That's all for the
function definition.

293
00:13:47,880 --> 00:13:52,740
def blah, blah, blah, indented,
everything inside the function.

294
00:13:52,740 --> 00:13:57,600
So this is you writing
the function definition.

295
00:13:57,600 --> 00:14:00,210
Once the function
definition's written,

296
00:14:00,210 --> 00:14:01,650
you can call the function.

297
00:14:01,650 --> 00:14:04,990
And that's this part down here.

298
00:14:04,990 --> 00:14:06,420
And here, when
you call function,

299
00:14:06,420 --> 00:14:10,284
you just say its name, and
then you give it parameters.

300
00:14:10,284 --> 00:14:11,700
And you give it
as many parameters

301
00:14:11,700 --> 00:14:13,980
as the function is expecting--
in this case, only one

302
00:14:13,980 --> 00:14:14,906
parameter.

303
00:14:23,000 --> 00:14:25,434
So what's inside
the function body?

304
00:14:25,434 --> 00:14:27,350
You can put anything
inside the function body.

305
00:14:27,350 --> 00:14:28,400
You remember,
think of a function

306
00:14:28,400 --> 00:14:30,650
as sort of a small procedure
or a little mini-program

307
00:14:30,650 --> 00:14:32,030
that does something.

308
00:14:32,030 --> 00:14:34,040
So you can do anything
inside the function

309
00:14:34,040 --> 00:14:37,250
that you can do in the regular
program-- print things,

310
00:14:37,250 --> 00:14:40,420
do mathematical
operations, and so on.

311
00:14:40,420 --> 00:14:42,880
The last line is the most
important part of the function

312
00:14:42,880 --> 00:14:44,950
though.

313
00:14:44,950 --> 00:14:47,900
And it's this return statement--
that's what we call it.

314
00:14:47,900 --> 00:14:50,610
So it's a line of code
that starts with return,

315
00:14:50,610 --> 00:14:52,910
which is a keyword.

316
00:14:52,910 --> 00:14:56,370
And then it's going
to be some value.

317
00:14:56,370 --> 00:14:58,340
Notice this is an
expression here--

318
00:14:58,340 --> 00:15:02,005
i%2 == 0 is an expression
that's going to evaluate to some

319
00:15:02,005 --> 00:15:02,505
value.

320
00:15:06,330 --> 00:15:08,990
And as long as this
part is something

321
00:15:08,990 --> 00:15:13,580
that evaluates some value,
it can be anything you want.

322
00:15:13,580 --> 00:15:16,850
And this line here return
something tells Python, OK

323
00:15:16,850 --> 00:15:19,040
after you have finished
executing everything

324
00:15:19,040 --> 00:15:24,280
inside the function, what
value should I return?

325
00:15:24,280 --> 00:15:26,780
And whoever called
the function is

326
00:15:26,780 --> 00:15:28,700
going to get back that
value, and the function

327
00:15:28,700 --> 00:15:32,253
call itself will be
replaced by that value.

328
00:15:32,253 --> 00:15:34,540
OK so let's look at an example.

329
00:15:39,370 --> 00:15:43,490
I'm going to introduce
the idea of scope now.

330
00:15:43,490 --> 00:15:49,830
And scope just means-- is
another word for environment.

331
00:15:49,830 --> 00:15:52,050
So if I told you that you
could think of functions

332
00:15:52,050 --> 00:15:55,610
as little mini-programs,
the scope of a function

333
00:15:55,610 --> 00:16:00,200
is going to be a completely
separate environment

334
00:16:00,200 --> 00:16:03,470
than the environment
of the main program.

335
00:16:03,470 --> 00:16:06,800
So as soon as you
make a function call,

336
00:16:06,800 --> 00:16:08,810
behind the scenes
what Python says is,

337
00:16:08,810 --> 00:16:12,170
OK I'm in the main program
but I see a function call.

338
00:16:12,170 --> 00:16:14,060
I'm going to step out
of this main program.

339
00:16:14,060 --> 00:16:16,880
I'm going to go off into
this new environment.

340
00:16:16,880 --> 00:16:19,820
I'm going to create entirely
new set of variables that just

341
00:16:19,820 --> 00:16:23,300
exist within this environment.

342
00:16:23,300 --> 00:16:25,240
I'm going to do
some computations.

343
00:16:25,240 --> 00:16:28,490
When I see the return, I'm going
to take this one return value.

344
00:16:28,490 --> 00:16:30,310
I'm going to exit
that environment,

345
00:16:30,310 --> 00:16:34,510
and then I'm going to come
back to the main program.

346
00:16:34,510 --> 00:16:37,150
So as you're entering
from one scope to another,

347
00:16:37,150 --> 00:16:40,850
you're sort of passing
these values back and forth.

348
00:16:40,850 --> 00:16:43,990
So when you're entering a scope,
you're passing a variable back

349
00:16:43,990 --> 00:16:46,455
into the function.

350
00:16:46,455 --> 00:16:47,830
And when the
function's finished,

351
00:16:47,830 --> 00:16:52,390
you're passing a value
back to whoever called it.

352
00:16:52,390 --> 00:16:56,050
So once again, this top part
is the function definition.

353
00:16:56,050 --> 00:16:59,200
And any arguments for
the function definition

354
00:16:59,200 --> 00:17:01,780
are called formal parameters.

355
00:17:01,780 --> 00:17:03,280
And they're called
formal parameters

356
00:17:03,280 --> 00:17:06,250
because notice they don't
actually have a value yet.

357
00:17:06,250 --> 00:17:08,079
In the function
definition, you're

358
00:17:08,079 --> 00:17:11,270
sort of writing the function
assuming that, in this case,

359
00:17:11,270 --> 00:17:13,609
x is going to have some value.

360
00:17:13,609 --> 00:17:16,630
But you don't know
what it is yet.

361
00:17:16,630 --> 00:17:19,690
You only know what
value x takes when you

362
00:17:19,690 --> 00:17:21,410
make a function call down here.

363
00:17:24,420 --> 00:17:25,920
So this is your
function definition,

364
00:17:25,920 --> 00:17:28,089
and then later on in
your main program,

365
00:17:28,089 --> 00:17:31,500
you might define some
variable x is equal to 3.

366
00:17:31,500 --> 00:17:33,660
And then you make
a function call.

367
00:17:33,660 --> 00:17:36,740
f of x here is
your function call.

368
00:17:39,350 --> 00:17:42,490
And it says, OK I'm
calling f with the value 3,

369
00:17:42,490 --> 00:17:45,610
because x takes the value 3,
and then I'm going to map 3

370
00:17:45,610 --> 00:17:46,420
into the function.

371
00:17:49,160 --> 00:17:51,651
The values that are passed
into the function call

372
00:17:51,651 --> 00:17:54,150
are called actual parameters,
because they're going actually

373
00:17:54,150 --> 00:17:54,710
have a value.

374
00:17:57,370 --> 00:18:00,340
So let's step through this
program-- this small program--

375
00:18:00,340 --> 00:18:03,880
and see what exactly happens
behind the scenes in the scope.

376
00:18:03,880 --> 00:18:05,670
And if you're just
starting to program,

377
00:18:05,670 --> 00:18:07,420
I think it would be
highly valuable if you

378
00:18:07,420 --> 00:18:11,140
take a piece of paper as you're
doing some of these exercises

379
00:18:11,140 --> 00:18:13,150
and you write down
something similar to what

380
00:18:13,150 --> 00:18:14,620
I'm going to go through here.

381
00:18:14,620 --> 00:18:16,870
I think it'll help
a lot, and you'll

382
00:18:16,870 --> 00:18:20,260
be able to see exactly
step-by-step what variables

383
00:18:20,260 --> 00:18:23,830
take what values and
which scope you're in.

384
00:18:23,830 --> 00:18:25,900
So here we go.

385
00:18:25,900 --> 00:18:27,760
When the program
first starts, we're

386
00:18:27,760 --> 00:18:29,730
creating this global scope.

387
00:18:29,730 --> 00:18:33,490
It's the main program scope.

388
00:18:33,490 --> 00:18:35,650
In the main program
scope, the first thing

389
00:18:35,650 --> 00:18:38,230
that Python is going
to see is this part

390
00:18:38,230 --> 00:18:44,740
here-- def f of x and
then some stuff inside.

391
00:18:44,740 --> 00:18:48,970
This tells Python I
have a function named x,

392
00:18:48,970 --> 00:18:52,450
but I don't care what's
inside the code yet.

393
00:18:52,450 --> 00:18:55,030
I don't care what's inside
the function definition

394
00:18:55,030 --> 00:18:59,570
yet, because I haven't
called the function yet.

395
00:18:59,570 --> 00:19:01,540
So to Python it's
just some code just

396
00:19:01,540 --> 00:19:04,155
sitting in the global scope.

397
00:19:07,480 --> 00:19:09,280
So whenever you see
def, you're just

398
00:19:09,280 --> 00:19:10,580
putting some code in there.

399
00:19:10,580 --> 00:19:13,390
Then you go onto the next
line-- x is equal to 3.

400
00:19:13,390 --> 00:19:17,980
So in the global scope, you now
have also a variable x is 3.

401
00:19:17,980 --> 00:19:20,230
And then the next
line-- z is equal to f

402
00:19:20,230 --> 00:19:22,750
of x is a function call.

403
00:19:22,750 --> 00:19:24,670
As soon as you hit
a function call,

404
00:19:24,670 --> 00:19:28,030
you create a new scope--
a new environment.

405
00:19:28,030 --> 00:19:31,651
So we're temporarily leaving
the global scope and sort

406
00:19:31,651 --> 00:19:35,740
of portaling into a
new scope, where we're

407
00:19:35,740 --> 00:19:38,530
going to try to figure out what
this function's going to do

408
00:19:38,530 --> 00:19:41,120
and what it's going to return.

409
00:19:41,120 --> 00:19:45,340
So the first thing you do
is you map the parameters.

410
00:19:45,340 --> 00:19:48,936
So x here-- I'm
calling f of x with 3--

411
00:19:48,936 --> 00:19:50,560
so first thing I'm
doing is I'm mapping

412
00:19:50,560 --> 00:19:53,780
every one of the parameters in
the definition to their values.

413
00:19:53,780 --> 00:19:56,182
So first thing I'm doing
is x gets the value 3.

414
00:19:59,690 --> 00:20:03,660
Next line here is x
is equal to x plus 1.

415
00:20:03,660 --> 00:20:06,120
So we're still inside
the function call f,

416
00:20:06,120 --> 00:20:07,490
so x gets the value 4.

417
00:20:10,260 --> 00:20:13,590
We're printing this and
then we're returning x.

418
00:20:13,590 --> 00:20:16,180
So in the scope of
f, x is equal to 4,

419
00:20:16,180 --> 00:20:18,060
so we're returning
that value back

420
00:20:18,060 --> 00:20:20,490
to whoever called it,
which was this function

421
00:20:20,490 --> 00:20:22,990
call within the global scope.

422
00:20:22,990 --> 00:20:25,590
So this part right here-- f
of x, which was the function

423
00:20:25,590 --> 00:20:28,590
call-- gets replaced with 4.

424
00:20:28,590 --> 00:20:33,780
So inside the main
program, z is equal to 4.

425
00:20:33,780 --> 00:20:36,860
And that's how we pass
parameters into the function,

426
00:20:36,860 --> 00:20:39,380
and we got a parameter
back from the function.

427
00:20:39,380 --> 00:20:42,210
As soon as the function
returns something,

428
00:20:42,210 --> 00:20:45,350
the scope that you were in
for the function gets erased.

429
00:20:45,350 --> 00:20:48,770
You forget about every variable
that was created in there,

430
00:20:48,770 --> 00:20:50,810
delete that scope, and
you're back to wherever

431
00:20:50,810 --> 00:20:53,900
you started calling it.

432
00:20:53,900 --> 00:20:55,520
One warning though.

433
00:20:55,520 --> 00:20:58,520
So what happens if there's
no return statement?

434
00:20:58,520 --> 00:21:02,540
I said that every function
has to return something.

435
00:21:02,540 --> 00:21:05,210
If you don't explicitly
put a return statement,

436
00:21:05,210 --> 00:21:07,520
Python is going to
add one for you.

437
00:21:07,520 --> 00:21:09,230
You don't have to do this.

438
00:21:09,230 --> 00:21:14,990
And it's going to actually
have return None-- N-o-n-e.

439
00:21:14,990 --> 00:21:18,620
And None is the
special type-- None

440
00:21:18,620 --> 00:21:22,510
is the value for a special
type called NoneType,

441
00:21:22,510 --> 00:21:24,260
and it represents the
absence of a value.

442
00:21:28,460 --> 00:21:29,170
What's that?

443
00:21:29,170 --> 00:21:30,310
Not a string.

444
00:21:30,310 --> 00:21:31,270
Not a--

445
00:21:31,270 --> 00:21:33,520
None is not a string.

446
00:21:33,520 --> 00:21:35,320
None is not a string, exactly.

447
00:21:35,320 --> 00:21:36,937
It's a special type.

448
00:21:40,070 --> 00:21:44,760
OK so before we go on, I wanted
to go through a small exercise

449
00:21:44,760 --> 00:21:46,930
in Spyder just to show
you the difference

450
00:21:46,930 --> 00:21:50,290
that None and printing
and returning makes.

451
00:21:50,290 --> 00:21:53,360
So here are two
functions that I wrote.

452
00:21:53,360 --> 00:21:55,240
One is is_even_with_return.

453
00:21:55,240 --> 00:21:58,790
That's its name, so
pretty descriptive.

454
00:21:58,790 --> 00:22:02,260
It's pretty much the same
code we saw in the slides.

455
00:22:02,260 --> 00:22:04,800
It just has this extra
little print thing.

456
00:22:04,800 --> 00:22:09,900
It gets the remainder
when i is divided by 2.

457
00:22:09,900 --> 00:22:13,330
And it returns whether the
remainder is equal to 0.

458
00:22:13,330 --> 00:22:18,320
So it'll either return a
true or a false-- a Boolean.

459
00:22:18,320 --> 00:22:23,490
OK so my function call is this:
I'm saying is_even_with_return

460
00:22:23,490 --> 00:22:26,910
with a value 3.

461
00:22:26,910 --> 00:22:29,310
When I make this
function call, this 3

462
00:22:29,310 --> 00:22:32,460
gets mapped into here--
this variable here--

463
00:22:32,460 --> 00:22:35,190
so i is equal to 3.

464
00:22:35,190 --> 00:22:37,320
I'm going to print with
return, and then I'm

465
00:22:37,320 --> 00:22:39,390
going to say remainder
is equal to 3 percent

466
00:22:39,390 --> 00:22:43,890
2, which comes out to value 1,
because there's a remainder 1.

467
00:22:43,890 --> 00:22:45,270
And I'm going to
return whether 1

468
00:22:45,270 --> 00:22:48,120
is equal to 0, which is false.

469
00:22:48,120 --> 00:22:51,660
So this line here
returns false, but am I

470
00:22:51,660 --> 00:22:53,400
doing anything with the false?

471
00:22:53,400 --> 00:22:54,660
Not really.

472
00:22:54,660 --> 00:22:57,510
It's just sort of
sitting in the code here.

473
00:22:57,510 --> 00:23:02,970
So this gets evaluated to false.

474
00:23:02,970 --> 00:23:03,829
I'm not printing it.

475
00:23:03,829 --> 00:23:05,370
I'm not doing any
operations with it.

476
00:23:05,370 --> 00:23:06,370
It's just sitting there.

477
00:23:06,370 --> 00:23:07,610
So it won't show up anywhere.

478
00:23:07,610 --> 00:23:09,360
If I want the result
to show up somewhere,

479
00:23:09,360 --> 00:23:10,390
then I have to print it.

480
00:23:10,390 --> 00:23:12,015
So that's what this
next line is doing.

481
00:23:15,540 --> 00:23:18,000
So that one should
be straightforward.

482
00:23:18,000 --> 00:23:19,960
is_even_without_return's
a little bit trickier,

483
00:23:19,960 --> 00:23:21,600
but not too bad.

484
00:23:21,600 --> 00:23:25,540
I have print,
without_return inside here,

485
00:23:25,540 --> 00:23:28,480
and then I'm going
to get a remainder is

486
00:23:28,480 --> 00:23:29,600
equal to i percent 2.

487
00:23:29,600 --> 00:23:32,620
And notice that I'm not--
I don't have any return.

488
00:23:32,620 --> 00:23:36,100
So implicitly, Python's going
to add a return None for me,

489
00:23:36,100 --> 00:23:36,809
like that.

490
00:23:36,809 --> 00:23:37,850
You don't have to add it.

491
00:23:40,760 --> 00:23:42,380
So when I make the
function call here,

492
00:23:42,380 --> 00:23:45,140
it's going to do the same thing,
except that return in this case

493
00:23:45,140 --> 00:23:46,370
is not going to be a Boolean.

494
00:23:46,370 --> 00:23:49,250
It's going to be
this special None.

495
00:23:49,250 --> 00:23:54,890
So this is going to
get evaluated to None.

496
00:23:54,890 --> 00:23:56,750
Again I'm not printing it out.

497
00:23:56,750 --> 00:23:59,150
It's just sitting there.

498
00:23:59,150 --> 00:24:03,670
If I were to print out
the result of that,

499
00:24:03,670 --> 00:24:06,820
you'd be printing out this
value None, which if I run it,

500
00:24:06,820 --> 00:24:11,770
you'll see here it just
prints it out right there.

501
00:24:11,770 --> 00:24:15,430
So as you're doing your next
p set, it's about functions

502
00:24:15,430 --> 00:24:18,370
and you're seeing these Nones
popping out in some places.

503
00:24:18,370 --> 00:24:20,980
Check to make sure that you've
actually returned something,

504
00:24:20,980 --> 00:24:24,260
as opposed to just printed
something inside the function

505
00:24:24,260 --> 00:24:24,970
like we did here.

506
00:24:29,352 --> 00:24:30,810
All right so that's
the difference.

507
00:24:30,810 --> 00:24:33,590
And the last thing I want to
mention about this is_even

508
00:24:33,590 --> 00:24:36,680
function is how
useful it can be.

509
00:24:36,680 --> 00:24:41,480
So notice this is the
function as in the slides,

510
00:24:41,480 --> 00:24:46,310
and once you write the
function once, you can use it

511
00:24:46,310 --> 00:24:48,140
many, many times in your code.

512
00:24:48,140 --> 00:24:51,740
So here I'm using
the function is_even

513
00:24:51,740 --> 00:24:54,650
to print the numbers
between 0 and 19, including

514
00:24:54,650 --> 00:24:57,900
and whether the
number is even or odd.

515
00:24:57,900 --> 00:25:00,020
So notice this
piece of code here,

516
00:25:00,020 --> 00:25:01,760
once I've written
this function is_even,

517
00:25:01,760 --> 00:25:05,270
looks really, really nice right?

518
00:25:05,270 --> 00:25:11,280
I have for all the numbers in
this range if the number i is

519
00:25:11,280 --> 00:25:16,710
even, this is going to
return a true or false

520
00:25:16,710 --> 00:25:20,130
for all the numbers
0, 1, 2, 3, 4.

521
00:25:20,130 --> 00:25:22,320
If it's true, then I'm
going to print out even,

522
00:25:22,320 --> 00:25:24,450
and otherwise I'm
going to print out odd.

523
00:25:24,450 --> 00:25:26,550
So if I run this,
it's going to do this.

524
00:25:26,550 --> 00:25:29,730
0 even, 1 odd, 2
even, and so on.

525
00:25:29,730 --> 00:25:34,159
So notice using functions makes
my code really nice looking.

526
00:25:34,159 --> 00:25:35,700
If I wasn't using
functions, I'd have

527
00:25:35,700 --> 00:25:40,796
to put these two lines
somewhere inside here

528
00:25:40,796 --> 00:25:42,420
and it would look a
little bit messier.

529
00:25:48,220 --> 00:25:50,000
So I've said this
maybe once or twice

530
00:25:50,000 --> 00:25:53,450
before: in Python
everything is an object.

531
00:25:56,660 --> 00:25:58,910
Might not have meant
anything back then,

532
00:25:58,910 --> 00:26:01,790
but I think you're
going to see what I mean

533
00:26:01,790 --> 00:26:04,470
using this particular example.

534
00:26:04,470 --> 00:26:09,320
So if in Python everything's an
object-- integers are objects,

535
00:26:09,320 --> 00:26:13,160
floats are objects, even
functions are objects.

536
00:26:13,160 --> 00:26:17,930
So as you can pass objects
as parameters back and forth

537
00:26:17,930 --> 00:26:21,140
as function parameters, you
can also pass other functions

538
00:26:21,140 --> 00:26:23,900
as parameters.

539
00:26:23,900 --> 00:26:25,550
Let's see what this means.

540
00:26:25,550 --> 00:26:29,420
So we have three function
definitions here-- func_a,

541
00:26:29,420 --> 00:26:33,050
func_b, and func_c.

542
00:26:33,050 --> 00:26:36,240
And then I have three lines of
code here in my main program.

543
00:26:36,240 --> 00:26:39,930
So I have one called a
func_a, one called a func_b,

544
00:26:39,930 --> 00:26:41,970
and one call to func_c.

545
00:26:41,970 --> 00:26:44,370
Let's trace through, just
like in the previous example,

546
00:26:44,370 --> 00:26:46,830
and see what exactly happens.

547
00:26:46,830 --> 00:26:50,010
First thing I create
is my global scope.

548
00:26:50,010 --> 00:26:52,249
And I have three
function definitions.

549
00:26:52,249 --> 00:26:53,790
Again I don't care
what's in the code

550
00:26:53,790 --> 00:26:56,160
yet, because I haven't
called the functions yet.

551
00:26:56,160 --> 00:26:59,160
Python just knows there's these
functions with these names that

552
00:26:59,160 --> 00:26:59,970
contain some code.

553
00:27:02,576 --> 00:27:04,950
After these definitions, I
come to this line here-- print

554
00:27:04,950 --> 00:27:06,100
func_a.

555
00:27:06,100 --> 00:27:08,125
As soon as I make
a function call,

556
00:27:08,125 --> 00:27:09,750
I'm going to create
a new scope and I'm

557
00:27:09,750 --> 00:27:11,970
going to hop into there.

558
00:27:11,970 --> 00:27:17,415
Inside func_a, I'm going to go
and look at what func_a does.

559
00:27:17,415 --> 00:27:18,960
It doesn't take
in the parameters,

560
00:27:18,960 --> 00:27:23,310
it just prints out
this message here.

561
00:27:23,310 --> 00:27:26,500
And then it leaves; it's done.

562
00:27:26,500 --> 00:27:30,460
There's no return,
so we return None.

563
00:27:30,460 --> 00:27:32,260
So func_a returns
None to whoever

564
00:27:32,260 --> 00:27:36,430
called it, which
was that line there,

565
00:27:36,430 --> 00:27:38,690
so that is going to be None.

566
00:27:42,950 --> 00:27:43,790
Next line.

567
00:27:43,790 --> 00:27:48,430
This one right here-- print
5 plus some function call.

568
00:27:48,430 --> 00:27:50,980
Again I'm going to hop
into func_b's scope

569
00:27:50,980 --> 00:27:52,150
and see what to do there.

570
00:27:52,150 --> 00:27:55,640
So first I'm going
to map my parameters.

571
00:27:55,640 --> 00:28:00,610
So 2-- whoops-- 2
gets mapped to y.

572
00:28:00,610 --> 00:28:03,275
So inside func_b's scope, y
is going to get the value 2.

573
00:28:03,275 --> 00:28:04,900
That's the very first
thing I'm doing--

574
00:28:04,900 --> 00:28:06,984
mapping all the parameters.

575
00:28:06,984 --> 00:28:08,650
Then I'm going to
print this thing here,

576
00:28:08,650 --> 00:28:10,960
and then I'm going to return y.

577
00:28:10,960 --> 00:28:13,120
So inside func_b,
y has the value 2,

578
00:28:13,120 --> 00:28:15,540
and I'm returning 2 back
to whoever called me.

579
00:28:18,480 --> 00:28:22,590
So this is the value
2 and I'm going

580
00:28:22,590 --> 00:28:24,130
to print 5 plus 2, which is 7.

581
00:28:26,830 --> 00:28:27,520
Last one.

582
00:28:27,520 --> 00:28:28,750
This is the trickiest.

583
00:28:28,750 --> 00:28:29,980
Oop, that popped up.

584
00:28:29,980 --> 00:28:31,900
If you think you've got
it, try that exercise.

585
00:28:31,900 --> 00:28:34,690
But otherwise follow along.

586
00:28:34,690 --> 00:28:38,620
print func_c func_a.

587
00:28:38,620 --> 00:28:45,100
So I see that I am going
to enter func_c's scope.

588
00:28:45,100 --> 00:28:48,120
So I'm going to look
at what func_c does.

589
00:28:48,120 --> 00:28:50,640
First thing I do is I'm
mapping all the parameters.

590
00:28:50,640 --> 00:28:52,380
Don't even worry about
the fact that this

591
00:28:52,380 --> 00:28:53,820
is a function right now.

592
00:28:53,820 --> 00:28:56,850
Just pretend it's
x or something.

593
00:28:56,850 --> 00:28:59,520
So you say func_a
is going to get

594
00:28:59,520 --> 00:29:03,390
mapped to the variable
z inside func_c.

595
00:29:03,390 --> 00:29:06,030
So z is func_c.

596
00:29:06,030 --> 00:29:10,190
Just mapping parameters
from actual to formal.

597
00:29:10,190 --> 00:29:11,810
Then what do we
do inside func_c?

598
00:29:11,810 --> 00:29:22,400
We print out inside func_c,
and then we return z.

599
00:29:22,400 --> 00:29:24,880
This is the cool part.

600
00:29:24,880 --> 00:29:29,170
Inside func_c, z is func_a.

601
00:29:29,170 --> 00:29:33,040
So if you replace z
with func_a, this here

602
00:29:33,040 --> 00:29:36,840
becomes return func_a
open close parentheses.

603
00:29:36,840 --> 00:29:38,710
Look familiar?

604
00:29:38,710 --> 00:29:40,960
We did that function
call right there right?

605
00:29:40,960 --> 00:29:42,520
So that's just
another function call.

606
00:29:48,222 --> 00:29:49,930
So with that being
another function call,

607
00:29:49,930 --> 00:29:51,670
you're going to
create another scope,

608
00:29:51,670 --> 00:29:53,500
and you're going to
pop into that one.

609
00:29:53,500 --> 00:29:57,050
So we're one, two, I
guess two scopes deep,

610
00:29:57,050 --> 00:29:59,480
and we're trying to figure
out where we're going.

611
00:29:59,480 --> 00:30:02,140
So func_a's scope is
going to be up here.

612
00:30:02,140 --> 00:30:03,400
So what does func_a do?

613
00:30:03,400 --> 00:30:06,700
It just prints out this,
and it returns None.

614
00:30:06,700 --> 00:30:08,380
So we're going to
return None to whoever

615
00:30:08,380 --> 00:30:12,210
called us, which was func_c.

616
00:30:12,210 --> 00:30:15,500
So this line here
becomes return None.

617
00:30:18,840 --> 00:30:20,810
And so this line here
is going to return None

618
00:30:20,810 --> 00:30:25,428
to whoever called it, which
was this line down here.

619
00:30:25,428 --> 00:30:28,860
Oops, I didn't mean
to cross that out.

620
00:30:28,860 --> 00:30:32,540
So that line here is
going to print None.

621
00:30:32,540 --> 00:30:35,600
So if you just go
step-by-step, it

622
00:30:35,600 --> 00:30:37,760
shouldn't be too
bad to try to map

623
00:30:37,760 --> 00:30:41,210
what happens with variable
names and formal parameters

624
00:30:41,210 --> 00:30:43,010
and actual parameters.

625
00:30:43,010 --> 00:30:48,020
That's why I highly recommend
pieces of paper and pens.

626
00:30:48,020 --> 00:30:51,590
One last thing I want
to mention about scope

627
00:30:51,590 --> 00:30:53,790
before we do another example.

628
00:30:53,790 --> 00:30:55,790
So there are three
sort of situations

629
00:30:55,790 --> 00:30:57,410
you might find yourself in.

630
00:30:57,410 --> 00:31:01,870
The first one is probably
the most typical,

631
00:31:01,870 --> 00:31:05,550
and this is when you
define a function.

632
00:31:05,550 --> 00:31:07,390
And it's using a
variable named x

633
00:31:07,390 --> 00:31:11,510
in this case that's also
defined outside of the function.

634
00:31:11,510 --> 00:31:16,480
And that doesn't matter
because of the idea of scopes.

635
00:31:16,480 --> 00:31:19,589
So inside the global scope,
you can have variables x.

636
00:31:19,589 --> 00:31:21,130
When you're inside
a different scope,

637
00:31:21,130 --> 00:31:23,830
you can have whatever
variable names you want.

638
00:31:23,830 --> 00:31:25,249
And when you're
inside that scope,

639
00:31:25,249 --> 00:31:27,040
Python's going to use
those variable names,

640
00:31:27,040 --> 00:31:30,530
so they don't interfere
with each other at all.

641
00:31:30,530 --> 00:31:33,340
So in this example, I've defined
a variable x is equal to 1,

642
00:31:33,340 --> 00:31:36,940
and then I incremented, and that
doesn't interfere with the fact

643
00:31:36,940 --> 00:31:40,360
that we have a
variable x outside.

644
00:31:40,360 --> 00:31:43,750
This one's a little
bit trickier.

645
00:31:43,750 --> 00:31:49,800
I define this function
g, and all g does

646
00:31:49,800 --> 00:31:52,110
is access a variable x.

647
00:31:52,110 --> 00:31:55,800
But notice inside g, I've
never actually declared

648
00:31:55,800 --> 00:31:58,620
or initialized a variable x.

649
00:31:58,620 --> 00:32:01,450
In this f, I said
x is equal to 1.

650
00:32:01,450 --> 00:32:05,720
But in here, I'm
just sort of using x.

651
00:32:05,720 --> 00:32:07,890
So this does not
give you an error.

652
00:32:07,890 --> 00:32:10,190
In fact it's OK for you
to do this in Python.

653
00:32:10,190 --> 00:32:11,930
Python says, OK
I'm in this scope,

654
00:32:11,930 --> 00:32:13,660
but I don't have
a variable named

655
00:32:13,660 --> 00:32:18,180
x, so let me just go into the
scope of whoever called me.

656
00:32:18,180 --> 00:32:21,050
So I'm going to just
temporarily hop out of the scope

657
00:32:21,050 --> 00:32:24,620
and see is there
variable x outside of me?

658
00:32:24,620 --> 00:32:26,390
And it'll find this
variable x here,

659
00:32:26,390 --> 00:32:28,992
and it's going to
print out its values.

660
00:32:28,992 --> 00:32:29,974
So that's OK.

661
00:32:33,420 --> 00:32:35,580
This last example here
is actually not allowed

662
00:32:35,580 --> 00:32:39,390
in Python-- similar to
this one-- except that I'm

663
00:32:39,390 --> 00:32:42,840
trying to increment
a value of x,

664
00:32:42,840 --> 00:32:45,150
but then I'm also
trying to reassign it

665
00:32:45,150 --> 00:32:47,730
to the same value of x.

666
00:32:47,730 --> 00:32:50,520
The problem with that is I
never actually initialized

667
00:32:50,520 --> 00:32:53,300
x inside h.

668
00:32:53,300 --> 00:32:58,230
So if I said-- if inside
h, I said x is equal to 1,

669
00:32:58,230 --> 00:33:00,440
and then I did x
plus equals to 1,

670
00:33:00,440 --> 00:33:03,650
then it would be this
example here-- f of y.

671
00:33:03,650 --> 00:33:05,280
But I didn't do that.

672
00:33:05,280 --> 00:33:10,580
I just tried to access
x and then incremented

673
00:33:10,580 --> 00:33:12,140
and then tried to reassign it.

674
00:33:12,140 --> 00:33:15,740
And that's actually
not allowed in Python.

675
00:33:15,740 --> 00:33:20,160
There is a way around it
using global variables.

676
00:33:20,160 --> 00:33:24,000
But it's actually frowned
upon to use global variables,

677
00:33:24,000 --> 00:33:26,240
though global variables
are part of the readings

678
00:33:26,240 --> 00:33:29,374
for this lecture.

679
00:33:29,374 --> 00:33:31,040
And the reason why
it's not a great idea

680
00:33:31,040 --> 00:33:34,700
to use global variables is
because global variables

681
00:33:34,700 --> 00:33:40,340
sort of give you this
loophole around scopes,

682
00:33:40,340 --> 00:33:45,530
so it allows you to write code
that can become very messy.

683
00:33:45,530 --> 00:33:48,530
So using global variables,
you can be inside a function

684
00:33:48,530 --> 00:33:50,960
and then modify a
variable that's defined

685
00:33:50,960 --> 00:33:53,310
outside of your function.

686
00:33:53,310 --> 00:33:55,910
And that sort of defeats
the purpose of functions

687
00:33:55,910 --> 00:33:59,370
and using them in writing
these coherent modules that

688
00:33:59,370 --> 00:34:00,370
are separate.

689
00:34:03,370 --> 00:34:07,880
That said, it might sometimes be
useful to use global variables,

690
00:34:07,880 --> 00:34:10,478
as you'll see in a
couple lectures from now.

691
00:34:13,110 --> 00:34:16,120
OK cool.

692
00:34:16,120 --> 00:34:19,449
So let's go on to the
last scope example.

693
00:34:19,449 --> 00:34:22,840
OK this slide is here,
and notice I've bolded,

694
00:34:22,840 --> 00:34:25,480
underlined, and italicized
the Python Tutor,

695
00:34:25,480 --> 00:34:28,246
because I find it
extremely helpful.

696
00:34:28,246 --> 00:34:29,870
So the Python Tutor--
as I've mentioned

697
00:34:29,870 --> 00:34:32,199
in one of the assignments--
it was actually developed

698
00:34:32,199 --> 00:34:34,250
by a grad student here,
or post-grad student

699
00:34:34,250 --> 00:34:36,260
slash post-doc here.

700
00:34:36,260 --> 00:34:41,889
And it allows you to go
through Python, paste a code,

701
00:34:41,889 --> 00:34:43,620
go through it step-by-step.

702
00:34:43,620 --> 00:34:45,489
Like with each
iteration, it'll show you

703
00:34:45,489 --> 00:34:48,760
exactly what values
each variable has,

704
00:34:48,760 --> 00:34:52,090
what scope you're in,
when scopes get created,

705
00:34:52,090 --> 00:34:55,760
when scopes get destroyed,
variables within each scope.

706
00:34:55,760 --> 00:34:57,460
So pretty much
every single detail

707
00:34:57,460 --> 00:35:00,360
you need to sort of
understand functions.

708
00:35:00,360 --> 00:35:02,990
As we're starting to-- you can
see we've had couple questions,

709
00:35:02,990 --> 00:35:05,297
and these were great questions.

710
00:35:05,297 --> 00:35:07,630
So if you're still trying to
understand what's going on,

711
00:35:07,630 --> 00:35:10,210
I would highly suggest
you take a piece of code

712
00:35:10,210 --> 00:35:11,740
and just run it in
the Python Tutor

713
00:35:11,740 --> 00:35:14,620
and you should be able to
see exactly what happens,

714
00:35:14,620 --> 00:35:19,900
in sort of a similar way
that I've drawn my diagrams.

715
00:35:19,900 --> 00:35:23,800
In all of the codes for
this particular lecture,

716
00:35:23,800 --> 00:35:25,617
I've put links to
the Python Tutor

717
00:35:25,617 --> 00:35:26,950
for each one of those exercises.

718
00:35:26,950 --> 00:35:29,140
So you can just copy
and paste those,

719
00:35:29,140 --> 00:35:30,730
and it'll automatically
populate it

720
00:35:30,730 --> 00:35:32,560
with that particular
example, so you just

721
00:35:32,560 --> 00:35:34,750
have to click, step, step, step.

722
00:35:34,750 --> 00:35:41,450
OK so having made my plug for
Python Tutor, let's go on.

723
00:35:41,450 --> 00:35:44,070
OK so here's an example.

724
00:35:44,070 --> 00:35:47,350
It's going to show
couple things.

725
00:35:47,350 --> 00:35:53,910
One is print versus return,
and also this idea of you

726
00:35:53,910 --> 00:35:55,452
can nest functions.

727
00:35:55,452 --> 00:35:57,160
So just like you could
have nested loops,

728
00:35:57,160 --> 00:35:59,700
nested conditionals-- you
can also nest functions

729
00:35:59,700 --> 00:36:02,530
within functions.

730
00:36:02,530 --> 00:36:07,320
So let's draw some diagrams
just like before of the scopes.

731
00:36:07,320 --> 00:36:09,960
First thing we're going to
do is when we have a program,

732
00:36:09,960 --> 00:36:11,790
we're going to create
the global scope

733
00:36:11,790 --> 00:36:14,725
and we're going to add
every variable that we have.

734
00:36:14,725 --> 00:36:16,350
And then when we
reach a function call,

735
00:36:16,350 --> 00:36:19,657
we're going to do
something about that.

736
00:36:19,657 --> 00:36:21,240
So the first thing
in the global scope

737
00:36:21,240 --> 00:36:25,140
is this function definition.

738
00:36:25,140 --> 00:36:28,740
Again in my global scope,
I just have g as some code

739
00:36:28,740 --> 00:36:31,290
because I have
not called it yet.

740
00:36:31,290 --> 00:36:34,660
I only go inside a function
when I make a function call.

741
00:36:34,660 --> 00:36:37,560
So g contains some code.

742
00:36:37,560 --> 00:36:41,820
So we're done with
75% of that code.

743
00:36:41,820 --> 00:36:45,390
Next line is x is equal to 3.

744
00:36:45,390 --> 00:36:48,330
So I'm making x be a variable
inside my global scope

745
00:36:48,330 --> 00:36:49,620
with value 3.

746
00:36:49,620 --> 00:36:54,090
And then I have this
z is equal to g of x.

747
00:36:54,090 --> 00:36:56,310
This is a function call.

748
00:36:56,310 --> 00:36:59,530
When I see a function call, I'm
going to create a new scope.

749
00:36:59,530 --> 00:37:00,920
So here is the scope of g.

750
00:37:03,510 --> 00:37:11,650
With the scope of g, I'm mapping
variables to actual parameters

751
00:37:11,650 --> 00:37:13,672
to formal parameters.

752
00:37:13,672 --> 00:37:15,130
So the first thing
I'm doing is I'm

753
00:37:15,130 --> 00:37:19,450
saying inside g what is the
value of actual parameter x?

754
00:37:19,450 --> 00:37:23,640
And x is going to be the
value 3, because I've called

755
00:37:23,640 --> 00:37:25,290
g of x with x is equal to 3.

756
00:37:29,880 --> 00:37:33,630
Next, what I see
inside this function--

757
00:37:33,630 --> 00:37:37,647
so this is the inside of the
function-- is this bit here.

758
00:37:40,390 --> 00:37:43,150
It's another
function definition.

759
00:37:43,150 --> 00:37:44,950
Again since I'm just
defining the function

760
00:37:44,950 --> 00:37:51,840
and I'm not calling it, all
Python sees is h is some code.

761
00:37:51,840 --> 00:37:53,420
I haven't called
the function h yet,

762
00:37:53,420 --> 00:37:57,420
because I'm just defining
it here with def.

763
00:37:57,420 --> 00:38:00,430
So that finishes this part here.

764
00:38:00,430 --> 00:38:04,630
The next line is x
is equal to x plus 1.

765
00:38:04,630 --> 00:38:08,640
So inside the scope of g,
I'm incrementing x to be 4.

766
00:38:08,640 --> 00:38:11,930
Then I'm printing out this line.

767
00:38:11,930 --> 00:38:15,030
And then I've reached here-- h.

768
00:38:15,030 --> 00:38:19,734
This is actually a function
call, and I'm calling h.

769
00:38:19,734 --> 00:38:21,150
As soon as I make
a function call,

770
00:38:21,150 --> 00:38:22,830
I'm creating another scope.

771
00:38:22,830 --> 00:38:25,660
So I'm temporarily going
out of the scope of g

772
00:38:25,660 --> 00:38:29,120
and going into the scope of h.

773
00:38:29,120 --> 00:38:31,320
So Python knows that
h contains some code,

774
00:38:31,320 --> 00:38:34,750
and now I can go inside h
and do whatever I need to do.

775
00:38:34,750 --> 00:38:38,090
So the first-- so h doesn't
have any parameters,

776
00:38:38,090 --> 00:38:42,350
so I don't need to populate
anything like that in there.

777
00:38:42,350 --> 00:38:48,820
h does define a variable called
x, which is abc; it's a string.

778
00:38:48,820 --> 00:38:53,110
And then that's all h does.

779
00:38:53,110 --> 00:38:54,155
What does it return?

780
00:38:57,240 --> 00:38:57,740
None.

781
00:38:57,740 --> 00:38:59,690
I heard murmuring,
but I think None

782
00:38:59,690 --> 00:39:00,980
was what you guys were saying.

783
00:39:00,980 --> 00:39:03,556
So since there's no
return statement,

784
00:39:03,556 --> 00:39:06,810
h is going to return None.

785
00:39:06,810 --> 00:39:09,400
So h returns None.

786
00:39:09,400 --> 00:39:13,790
Back to whoever called it,
which was this code inside g.

787
00:39:13,790 --> 00:39:15,620
So that gets
replaced with None--

788
00:39:15,620 --> 00:39:19,820
the thing that I've--
this circled red h here.

789
00:39:19,820 --> 00:39:22,004
As soon as h
returns, we're going

790
00:39:22,004 --> 00:39:24,170
to get rid of that scope--
all the variables created

791
00:39:24,170 --> 00:39:27,530
within it-- and
we're done with h.

792
00:39:27,530 --> 00:39:29,300
So now we're back into g.

793
00:39:29,300 --> 00:39:31,760
And we just finished
executing this

794
00:39:31,760 --> 00:39:34,860
and this got replaced with None.

795
00:39:34,860 --> 00:39:38,840
We're not printing it out, so
this doesn't show up anywhere;

796
00:39:38,840 --> 00:39:41,156
it's just there.

797
00:39:41,156 --> 00:39:42,530
So we're finished
with that line.

798
00:39:42,530 --> 00:39:43,810
And the next line is return x.

799
00:39:46,990 --> 00:39:50,650
So x inside g is 4,
so 4 gets returned

800
00:39:50,650 --> 00:39:54,970
back to whoever called it, which
was in the global scope here.

801
00:39:54,970 --> 00:39:56,830
So this gets replaced with 4.

802
00:39:59,660 --> 00:40:03,200
So once we've returned x,
we've completely exited out

803
00:40:03,200 --> 00:40:07,100
of the scope of g,
and we've come back

804
00:40:07,100 --> 00:40:10,520
to whoever called us,
which was global scope

805
00:40:10,520 --> 00:40:12,080
and we've replaced
z is equal to g

806
00:40:12,080 --> 00:40:14,420
of x and that completely
got replaced with 4-- the

807
00:40:14,420 --> 00:40:15,185
returned value.

808
00:40:18,060 --> 00:40:23,020
So that's sort of
showing nested functions.

809
00:40:23,020 --> 00:40:25,790
All right just circling back
to decomposition-abstraction.

810
00:40:25,790 --> 00:40:27,070
This is the last slide.

811
00:40:27,070 --> 00:40:30,910
You can see if you look
at the code associated

812
00:40:30,910 --> 00:40:33,557
with today's lecture, there
are some other examples

813
00:40:33,557 --> 00:40:35,140
where you can see
just how powerful it

814
00:40:35,140 --> 00:40:36,160
is to use functions.

815
00:40:36,160 --> 00:40:38,500
And you can write really
clean and simple code

816
00:40:38,500 --> 00:40:43,130
if you define your own functions
and then just use them later.

817
00:40:43,130 --> 00:40:45,040
And the beauty of defining
your own functions

818
00:40:45,040 --> 00:40:46,630
that you can use
multiple times later

819
00:40:46,630 --> 00:40:49,210
is you only have to debug
the function once right?

820
00:40:49,210 --> 00:40:51,122
I know debugging is not
your favorite thing,

821
00:40:51,122 --> 00:40:53,080
but you only have to
debug this one thing once,

822
00:40:53,080 --> 00:40:55,620
and then you can know that
it's right and it works well,

823
00:40:55,620 --> 00:40:58,090
and you can just use
it multiple times.

824
00:40:58,090 --> 00:41:00,990
All right thanks everyone.