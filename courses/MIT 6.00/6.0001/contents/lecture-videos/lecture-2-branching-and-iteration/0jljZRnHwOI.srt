1
00:00:00,790 --> 00:00:03,190
The following content is
provided under a Creative

2
00:00:03,190 --> 00:00:04,730
Commons license.

3
00:00:04,730 --> 00:00:07,030
Your support will help
MIT OpenCourseWare

4
00:00:07,030 --> 00:00:11,390
continue to offer high quality
educational resources for free.

5
00:00:11,390 --> 00:00:13,990
To make a donation or
view additional materials

6
00:00:13,990 --> 00:00:17,880
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:17,880 --> 00:00:18,840
at ocw.mit.edu.

8
00:00:31,140 --> 00:00:33,100
PROFESSOR: All right.

9
00:00:33,100 --> 00:00:35,120
Let's get started, everyone.

10
00:00:35,120 --> 00:00:37,340
So, good afternoon.

11
00:00:37,340 --> 00:00:42,470
Welcome to the second lecture
of 60001 and also of 600.

12
00:00:42,470 --> 00:00:46,000
So as always, if you'd like to
follow along with the lectures,

13
00:00:46,000 --> 00:00:48,190
please go ahead and download
the slides and the code

14
00:00:48,190 --> 00:00:53,270
that I'll provide at least an
hour before class every day.

15
00:00:53,270 --> 00:00:53,770
All right.

16
00:00:53,770 --> 00:00:56,420
So a quick recap of
what we did last time.

17
00:00:56,420 --> 00:01:00,610
So last time, we talked a little
bit about what a computer is.

18
00:01:00,610 --> 00:01:03,130
And I think the main takeaway
from the last lecture

19
00:01:03,130 --> 00:01:06,730
is really that a computer only
does what it is told, right?

20
00:01:06,730 --> 00:01:08,800
So it's not going to
spontaneously make

21
00:01:08,800 --> 00:01:10,090
decisions on its own.

22
00:01:10,090 --> 00:01:12,670
You, as the programmer,
have to tell it

23
00:01:12,670 --> 00:01:15,501
what you want it to do
by writing programs.

24
00:01:15,501 --> 00:01:16,000
OK.

25
00:01:16,000 --> 00:01:18,610
So we talked about
simple objects.

26
00:01:18,610 --> 00:01:22,000
And these objects were
of different types.

27
00:01:22,000 --> 00:01:25,060
So we saw integers,
floats, and Booleans.

28
00:01:25,060 --> 00:01:28,390
And then we did a couple of
simple operations with them.

29
00:01:28,390 --> 00:01:30,250
Today, we're going to
look at a different--

30
00:01:30,250 --> 00:01:33,850
a new type of object
called a string.

31
00:01:33,850 --> 00:01:35,230
And then we're
going to introduce

32
00:01:35,230 --> 00:01:42,120
some more powerful things
in our programming toolbox.

33
00:01:42,120 --> 00:01:44,710
So we're going to look at how
to branch within a program,

34
00:01:44,710 --> 00:01:47,440
and how to make things-- how
to make the computer repeat

35
00:01:47,440 --> 00:01:50,200
certain tasks
within our program.

36
00:01:50,200 --> 00:01:51,130
All right.

37
00:01:51,130 --> 00:01:53,530
So let's begin by
looking at strings.

38
00:01:53,530 --> 00:01:56,530
So strings are a
new object type.

39
00:01:56,530 --> 00:01:58,030
We've seen so far
integers, which

40
00:01:58,030 --> 00:02:02,380
were whole numbers, floats,
which were decimal numbers,

41
00:02:02,380 --> 00:02:05,910
and we have seen Booleans,
which were true and false.

42
00:02:05,910 --> 00:02:09,789
So strings are going to be
sequences of characters.

43
00:02:09,789 --> 00:02:11,680
And these characters
can be anything.

44
00:02:11,680 --> 00:02:14,840
They can be letters,
digits, special characters,

45
00:02:14,840 --> 00:02:17,050
and also spaces.

46
00:02:17,050 --> 00:02:20,560
And you tell Python that you're
talking about a string object

47
00:02:20,560 --> 00:02:23,320
by enclosing it in
quotation marks.

48
00:02:23,320 --> 00:02:29,860
So in this case, I'm creating an
object whose value is h-e-l-l-o

49
00:02:29,860 --> 00:02:32,674
space t-h-e-r-e.

50
00:02:32,674 --> 00:02:34,840
And Python knows it's a
string object, because we're

51
00:02:34,840 --> 00:02:36,387
enclosing it in quotations.

52
00:02:36,387 --> 00:02:38,470
They can be either double
quotes or single quotes,

53
00:02:38,470 --> 00:02:41,260
but as long as you're
consistent, it doesn't matter.

54
00:02:41,260 --> 00:02:46,740
And this object, we're binding
it to this variable named hi.

55
00:02:46,740 --> 00:02:49,210
And we're using that using
the equals sign, which

56
00:02:49,210 --> 00:02:51,540
is the assignment operator.

57
00:02:51,540 --> 00:02:55,320
So from now on, whenever we
refer to this variable hi,

58
00:02:55,320 --> 00:02:57,700
Python is going to say, oh,
I know what the value is,

59
00:02:57,700 --> 00:03:00,864
and it's that string
of characters.

60
00:03:00,864 --> 00:03:02,530
So we're going to
learn about two things

61
00:03:02,530 --> 00:03:05,260
that you can do on strings
today, two operations.

62
00:03:05,260 --> 00:03:07,150
One is to concatenate them.

63
00:03:07,150 --> 00:03:09,700
And concatenation is
really just a fancy word

64
00:03:09,700 --> 00:03:11,920
for using this plus
operator, which

65
00:03:11,920 --> 00:03:14,810
means put the strings together.

66
00:03:14,810 --> 00:03:18,640
So I have this original
variable named hi,

67
00:03:18,640 --> 00:03:20,920
and I create a new
variable called name.

68
00:03:20,920 --> 00:03:24,550
And in it, I'm going
to assign the string

69
00:03:24,550 --> 00:03:27,290
a-n-a to the variable name.

70
00:03:27,290 --> 00:03:31,060
And when I use the plus
operator in between hi and name,

71
00:03:31,060 --> 00:03:32,920
those two variables,
Python is going

72
00:03:32,920 --> 00:03:34,930
to look at the
values of those two,

73
00:03:34,930 --> 00:03:38,330
and it's going to just
put them together.

74
00:03:38,330 --> 00:03:39,810
OK.

75
00:03:39,810 --> 00:03:43,140
I'm going to switch to Spider.

76
00:03:43,140 --> 00:03:49,717
And this is just that
example from the slides.

77
00:03:49,717 --> 00:03:50,800
So let's see what happens.

78
00:03:50,800 --> 00:03:54,790
So I have the variable
hi, the variable name,

79
00:03:54,790 --> 00:03:57,250
and I'm just concatenating
those two together.

80
00:03:57,250 --> 00:03:59,480
And then I'm going
to print that out.

81
00:03:59,480 --> 00:04:05,450
So if I run the code, notice
it prints out "hello thereana."

82
00:04:05,450 --> 00:04:06,590
There's no space.

83
00:04:06,590 --> 00:04:09,660
And there's no space because
the concatenation operator,

84
00:04:09,660 --> 00:04:13,490
the plus, doesn't add
any spaces implicitly.

85
00:04:13,490 --> 00:04:16,430
So again, another example
of just computer just

86
00:04:16,430 --> 00:04:17,839
doing what it's told.

87
00:04:17,839 --> 00:04:20,570
If we want to add a space,
we'd have to actually insert

88
00:04:20,570 --> 00:04:22,370
the space manually.

89
00:04:22,370 --> 00:04:25,340
So that's this
line here, line 8.

90
00:04:25,340 --> 00:04:27,230
And in this line,
we're concatenating

91
00:04:27,230 --> 00:04:31,440
the value of the
variable hi with a space.

92
00:04:31,440 --> 00:04:33,800
Notice we're putting
it in quotation marks.

93
00:04:33,800 --> 00:04:34,850
Just a space.

94
00:04:34,850 --> 00:04:37,070
And then with name.

95
00:04:37,070 --> 00:04:41,520
So if we'll go ahead
and print that value,

96
00:04:41,520 --> 00:04:45,480
notice this was that
garbage greeting there.

97
00:04:45,480 --> 00:04:47,610
And now we have a
proper greeting, right?

98
00:04:52,850 --> 00:04:56,301
So that's the concatenation
between strings.

99
00:04:56,301 --> 00:04:57,800
And then the other
thing we're going

100
00:04:57,800 --> 00:05:04,190
to look at related to
strings is the star operator.

101
00:05:04,190 --> 00:05:07,250
So that's this one
here on line 10.

102
00:05:07,250 --> 00:05:09,760
So Python allows you to use
the star operator, which

103
00:05:09,760 --> 00:05:15,420
stands for multiplication,
between a string and a number.

104
00:05:15,420 --> 00:05:19,070
And when you do that,
Python interprets it

105
00:05:19,070 --> 00:05:25,500
as repeat that string
that many number of times.

106
00:05:25,500 --> 00:05:29,150
So in this case, I'm
creating a silly greeting,

107
00:05:29,150 --> 00:05:33,500
and I'm concatenating the value
of hi, which is "hello there"

108
00:05:33,500 --> 00:05:37,329
with the space plus the name.

109
00:05:37,329 --> 00:05:38,870
So notice here, I'm
using parentheses

110
00:05:38,870 --> 00:05:42,350
to tell Python, do this
operation first, and then

111
00:05:42,350 --> 00:05:48,200
multiply whatever the
result of this is by 3.

112
00:05:48,200 --> 00:05:51,750
So if I print that
out, it's going

113
00:05:51,750 --> 00:05:55,320
to multiply the space
with my name three times,

114
00:05:55,320 --> 00:05:58,080
and it's going to concatenate
that with "hello there."

115
00:05:58,080 --> 00:06:02,670
So that's exactly what
it printed out there.

116
00:06:02,670 --> 00:06:05,180
Last lecture, we talked
a little bit about print.

117
00:06:05,180 --> 00:06:09,070
Today, I'm going to talk about
some nuances related to print.

118
00:06:09,070 --> 00:06:12,700
So you use print to
interact with the user.

119
00:06:12,700 --> 00:06:15,720
It's cool to write programs that
print things out to the user.

120
00:06:15,720 --> 00:06:19,110
So the key word
here being print.

121
00:06:19,110 --> 00:06:22,080
And then you put
parentheses after print.

122
00:06:22,080 --> 00:06:25,230
And in the parentheses,
you put in whatever

123
00:06:25,230 --> 00:06:27,760
you want to show the user.

124
00:06:27,760 --> 00:06:30,150
So in this little
program, I have--

125
00:06:30,150 --> 00:06:31,980
I created a variable named x.

126
00:06:31,980 --> 00:06:35,790
I assigned it the value
1, and then I print 1.

127
00:06:35,790 --> 00:06:38,390
Here, I'm casting.

128
00:06:38,390 --> 00:06:40,860
So I'm taking the number
one, the integer 1,

129
00:06:40,860 --> 00:06:43,560
and I'm casting it to a string.

130
00:06:43,560 --> 00:06:46,170
And you'll see why in a moment.

131
00:06:46,170 --> 00:06:47,670
So I want to bring
to your attention

132
00:06:47,670 --> 00:06:48,670
a couple of things here.

133
00:06:48,670 --> 00:06:54,780
So in the first print, I'm
using commas everywhere here.

134
00:06:54,780 --> 00:06:56,550
And in the second
print, I'm using plus.

135
00:07:01,100 --> 00:07:04,340
So by definition, if
you-- you can use commas

136
00:07:04,340 --> 00:07:08,840
inside a print-- inside
the parentheses of print.

137
00:07:08,840 --> 00:07:13,760
And if you use a comma, Python
is going to automatically

138
00:07:13,760 --> 00:07:17,090
add a space in
between the two things

139
00:07:17,090 --> 00:07:20,100
that the comma is in
between, the values.

140
00:07:20,100 --> 00:07:23,490
So "my fav num is"
is the first thing.

141
00:07:23,490 --> 00:07:27,320
And the second thing is
whatever's after the comma.

142
00:07:27,320 --> 00:07:29,090
Let's take x.

143
00:07:29,090 --> 00:07:32,120
So if you use a comma, Python
is going to automatically insert

144
00:07:32,120 --> 00:07:34,580
a space for you.

145
00:07:34,580 --> 00:07:36,920
Sometimes, you might want
that, sometimes you might not.

146
00:07:36,920 --> 00:07:39,980
If you don't want that, you
can use the concatenation

147
00:07:39,980 --> 00:07:41,990
operation, the plus.

148
00:07:41,990 --> 00:07:44,390
And you can add all
of your little bits

149
00:07:44,390 --> 00:07:48,210
together to create
one big string.

150
00:07:48,210 --> 00:07:50,900
If you're using
commas, the items,

151
00:07:50,900 --> 00:07:52,340
the objects in
between the commas,

152
00:07:52,340 --> 00:07:54,350
do not all have to be strings.

153
00:07:54,350 --> 00:07:56,150
That's the plus side
of using commas.

154
00:07:56,150 --> 00:08:00,020
But the downside is you
get spaces everywhere.

155
00:08:00,020 --> 00:08:03,590
If you use plus
operator, the plus side

156
00:08:03,590 --> 00:08:06,890
is Python does exactly
what you tell it to do,

157
00:08:06,890 --> 00:08:09,320
but everything has to
be a string object.

158
00:08:09,320 --> 00:08:12,680
So "my fav num is"
is a string object.

159
00:08:12,680 --> 00:08:15,800
You have to convert all of
your numbers to string objects,

160
00:08:15,800 --> 00:08:18,330
and so on.

161
00:08:18,330 --> 00:08:29,740
So if we look at Spider--
This is the same-- almost

162
00:08:29,740 --> 00:08:30,940
the same code.

163
00:08:30,940 --> 00:08:34,070
So here, I don't
have spaces anywhere.

164
00:08:34,070 --> 00:08:37,780
So you can see that
the first line here

165
00:08:37,780 --> 00:08:39,590
has commas everywhere.

166
00:08:39,590 --> 00:08:43,120
So I'm going to have spaces in
between every one of the things

167
00:08:43,120 --> 00:08:47,310
that I'm printing out.

168
00:08:47,310 --> 00:08:50,970
This line here is sort of a
combination between commas

169
00:08:50,970 --> 00:08:54,250
and concatenation.

170
00:08:54,250 --> 00:08:56,600
So depending on where
I used the comma,

171
00:08:56,600 --> 00:08:58,020
I'm going to have
an extra space.

172
00:08:58,020 --> 00:09:02,100
And this line here just has
concatenation everywhere.

173
00:09:02,100 --> 00:09:08,240
So if I run this, notice this
very first line added spaces

174
00:09:08,240 --> 00:09:10,020
everywhere in between
all my objects.

175
00:09:10,020 --> 00:09:11,949
The second one added
spaces somewhere.

176
00:09:11,949 --> 00:09:14,240
And you can sort of trace
through and see exactly where

177
00:09:14,240 --> 00:09:16,360
the spaces were added.

178
00:09:16,360 --> 00:09:21,018
And the last line here
didn't add spaces anywhere.

179
00:09:33,220 --> 00:09:37,590
So printing things out
to the console is nice,

180
00:09:37,590 --> 00:09:40,860
but the second part of sort of
writing an interactive program

181
00:09:40,860 --> 00:09:43,170
is getting input from the user.

182
00:09:43,170 --> 00:09:45,510
And that's the more
interesting part.

183
00:09:45,510 --> 00:09:49,140
So if you've done problem set 0,
you might have sort of already

184
00:09:49,140 --> 00:09:50,710
tried to understand
this on your own.

185
00:09:50,710 --> 00:09:52,050
But here we are.

186
00:09:52,050 --> 00:09:55,650
So the way you get
input from the user

187
00:09:55,650 --> 00:10:00,030
is using this command
function called input.

188
00:10:00,030 --> 00:10:03,630
And inside the parentheses,
you type in whatever you'd

189
00:10:03,630 --> 00:10:07,810
like to prompt the user with.

190
00:10:07,810 --> 00:10:11,490
So in this case, in my
example here, I have input,

191
00:10:11,490 --> 00:10:14,070
and then here I said
"type anything."

192
00:10:14,070 --> 00:10:16,740
So the user is going
to see this text here,

193
00:10:16,740 --> 00:10:19,332
and then the program
is just going to stop.

194
00:10:19,332 --> 00:10:20,790
And it's going to
wait for the user

195
00:10:20,790 --> 00:10:23,760
to type in something
and hit Enter.

196
00:10:23,760 --> 00:10:27,120
As soon as the user
types in Enter,

197
00:10:27,120 --> 00:10:31,470
whatever the user types
in becomes a string.

198
00:10:31,470 --> 00:10:33,810
If a user types in a
number, for example,

199
00:10:33,810 --> 00:10:36,804
that becomes the
string of that number.

200
00:10:36,804 --> 00:10:38,220
So everything the
user types in is

201
00:10:38,220 --> 00:10:39,930
going to be made as a string.

202
00:10:43,180 --> 00:10:46,090
In this line right here,
whatever these the user types

203
00:10:46,090 --> 00:10:47,890
in becomes a string.

204
00:10:47,890 --> 00:10:50,770
And we're going to
bind that string object

205
00:10:50,770 --> 00:10:54,597
to this variable named text.

206
00:10:54,597 --> 00:10:56,680
So now, further in my
program, I could do whatever

207
00:10:56,680 --> 00:10:58,270
I want with this variable text.

208
00:10:58,270 --> 00:11:02,320
In this case, I'm
going to print 5*text.

209
00:11:02,320 --> 00:11:03,580
OK.

210
00:11:03,580 --> 00:11:07,120
So if the user, for
example, gave me "ha,"

211
00:11:07,120 --> 00:11:10,030
I'm going to print "ha" 5 times.

212
00:11:10,030 --> 00:11:13,609
If the user gave
me 5, what do you

213
00:11:13,609 --> 00:11:15,150
think the user is--
what do you think

214
00:11:15,150 --> 00:11:18,380
is going to be printed out?

215
00:11:18,380 --> 00:11:22,551
25 or 5 five times?

216
00:11:22,551 --> 00:11:23,050
Great.

217
00:11:23,050 --> 00:11:23,290
Yes.

218
00:11:23,290 --> 00:11:23,789
Exactly.

219
00:11:23,789 --> 00:11:24,718
5 five times.

220
00:11:28,270 --> 00:11:31,700
Oftentimes, you don't want to
work with numbers as strings,

221
00:11:31,700 --> 00:11:32,200
right?

222
00:11:32,200 --> 00:11:34,690
You want to work with
numbers as numbers, right?

223
00:11:34,690 --> 00:11:36,826
So you have to cast.

224
00:11:36,826 --> 00:11:38,200
And we learned
that last lecture.

225
00:11:38,200 --> 00:11:41,020
You cast by just putting
in this little bit

226
00:11:41,020 --> 00:11:43,304
right in front of the input.

227
00:11:43,304 --> 00:11:45,220
And you can cast it to
whatever type you want.

228
00:11:45,220 --> 00:11:48,310
Here I cast it to an int, but
you can also cast to a float

229
00:11:48,310 --> 00:11:50,620
if you want to work with floats.

230
00:11:50,620 --> 00:11:53,770
And that converts whatever
the user typed in,

231
00:11:53,770 --> 00:11:57,340
as long as it's some number that
Python knows how to convert,

232
00:11:57,340 --> 00:11:59,150
into the number itself.

233
00:11:59,150 --> 00:12:01,270
So in this case, if
the user gives me 5,

234
00:12:01,270 --> 00:12:07,190
I'm going to print out 5 times
5 instead of 5 five times.

235
00:12:07,190 --> 00:12:12,300
So that's the code here.

236
00:12:14,870 --> 00:12:16,570
So the first bit
is I'm going to get

237
00:12:16,570 --> 00:12:23,190
the user to type in anything,
and I'm going to put 555.

238
00:12:23,190 --> 00:12:25,680
And then when I type in the
number, since I'm casting it,

239
00:12:25,680 --> 00:12:27,920
I'm going to do operations
with the number.

240
00:12:27,920 --> 00:12:28,620
Yeah, question.

241
00:12:28,620 --> 00:12:29,574
AUDIENCE: [INAUDIBLE]

242
00:12:32,440 --> 00:12:37,510
PROFESSOR: Why do you
want to cast to-- oh.

243
00:12:37,510 --> 00:12:41,035
The question is why do you
want to cast to a string?

244
00:12:41,035 --> 00:12:42,910
Why do you want to cast
a string to a number?

245
00:12:42,910 --> 00:12:43,884
AUDIENCE: [INAUDIBLE]

246
00:12:46,810 --> 00:12:50,320
PROFESSOR: Oh, so
Python always--

247
00:12:50,320 --> 00:12:53,170
whatever you type
in, just by default,

248
00:12:53,170 --> 00:12:55,300
by definition of
the input command,

249
00:12:55,300 --> 00:12:58,030
Python always makes it a string.

250
00:12:58,030 --> 00:12:59,530
So if you want to
work with numbers,

251
00:12:59,530 --> 00:13:00,988
you have to explicitly
tell it, I'm

252
00:13:00,988 --> 00:13:03,200
going to work with a number.

253
00:13:03,200 --> 00:13:04,750
So even if you give
it the number 5,

254
00:13:04,750 --> 00:13:08,270
it's going to think
it's the string 5.

255
00:13:08,270 --> 00:13:09,120
Yeah.

256
00:13:09,120 --> 00:13:10,445
That's just how input works.

257
00:13:13,960 --> 00:13:18,190
The next thing we're
going to look at

258
00:13:18,190 --> 00:13:25,330
is ways that you can start
adding tests in your code.

259
00:13:25,330 --> 00:13:29,710
And before you can start
adding tests in your code,

260
00:13:29,710 --> 00:13:32,800
you need to be able to
do the actual tests.

261
00:13:32,800 --> 00:13:39,850
So this is where comparison
operators come in.

262
00:13:39,850 --> 00:13:44,650
So here, let's assume that
i and j are variables.

263
00:13:44,650 --> 00:13:48,070
The following comparisons are
going to give you a Boolean.

264
00:13:48,070 --> 00:13:51,500
So it's either going to say,
this is true or this is false.

265
00:13:51,500 --> 00:13:54,850
So that's going to be your test.

266
00:13:54,850 --> 00:13:56,830
So if i and j are
variables, you're

267
00:13:56,830 --> 00:13:58,390
allowed to compare
ints with ints,

268
00:13:58,390 --> 00:14:01,900
floats with floats,
strings with strings.

269
00:14:01,900 --> 00:14:03,340
And you're allowed
to compare ints

270
00:14:03,340 --> 00:14:05,500
and floats between
themselves, but you're not

271
00:14:05,500 --> 00:14:09,520
allowed to compare a
string with a number.

272
00:14:09,520 --> 00:14:13,330
In fact, if you even try to
do that in Python-- in Spider

273
00:14:13,330 --> 00:14:18,370
here, if I try to say, is
the letter a greater than 5?

274
00:14:18,370 --> 00:14:22,390
I get some angry
text right here.

275
00:14:22,390 --> 00:14:24,370
And this just tells
me Python doesn't

276
00:14:24,370 --> 00:14:26,320
understand the
meaning of-- how do I

277
00:14:26,320 --> 00:14:27,615
compare a string with a number?

278
00:14:30,900 --> 00:14:31,840
OK.

279
00:14:31,840 --> 00:14:36,120
So just like in math, we can
do these usual comparisons.

280
00:14:36,120 --> 00:14:38,220
We can say if something
is greater than something,

281
00:14:38,220 --> 00:14:41,160
greater or equal to, less
than, less than or equal to.

282
00:14:41,160 --> 00:14:44,410
I'd like to bring to your
attention the equality.

283
00:14:44,410 --> 00:14:46,801
So the single equals
sign is an assignment.

284
00:14:46,801 --> 00:14:48,300
So you're taking a
value, and you're

285
00:14:48,300 --> 00:14:49,424
assigning it to a variable.

286
00:14:49,424 --> 00:14:51,420
But when you're doing
the double equals sign,

287
00:14:51,420 --> 00:14:53,580
this is the test for equality.

288
00:14:53,580 --> 00:14:55,830
Is the value of
variable i the same

289
00:14:55,830 --> 00:14:58,262
as the value of the variable j?

290
00:14:58,262 --> 00:14:59,970
And that's, again,
also going to give you

291
00:14:59,970 --> 00:15:02,230
a Boolean either true or false.

292
00:15:02,230 --> 00:15:05,450
And you can also test for
inequality with the exclamation

293
00:15:05,450 --> 00:15:06,720
equal.

294
00:15:06,720 --> 00:15:09,290
So that means, is the
value of the variable i

295
00:15:09,290 --> 00:15:12,030
not equal to the value
of the variable j?

296
00:15:12,030 --> 00:15:13,890
True if yes, false if no.

297
00:15:16,760 --> 00:15:17,260
OK.

298
00:15:17,260 --> 00:15:19,470
So those are comparison
operators on integer,

299
00:15:19,470 --> 00:15:21,210
floats, and strings.

300
00:15:21,210 --> 00:15:25,620
On Booleans, you can do
some logic operators.

301
00:15:25,620 --> 00:15:30,610
And the simplest
is just inverting.

302
00:15:30,610 --> 00:15:35,760
So if a is a variable
that has a Boolean value,

303
00:15:35,760 --> 00:15:37,450
not a is just
going to invert it.

304
00:15:37,450 --> 00:15:42,620
So if a is true, then not
a is false, and vice versa.

305
00:15:42,620 --> 00:15:45,940
This is a table that sort of
represents what I've said here.

306
00:15:45,940 --> 00:15:49,750
So you can do-- you
can use and and or.

307
00:15:49,750 --> 00:15:52,060
These are key words in Python.

308
00:15:52,060 --> 00:15:54,700
You can use those two
key words on variables,

309
00:15:54,700 --> 00:15:57,850
on Boolean variables.

310
00:15:57,850 --> 00:16:01,870
And you get the result
a and b is only true

311
00:16:01,870 --> 00:16:04,720
if both a and b are true.

312
00:16:04,720 --> 00:16:11,020
And a or b is only false
if a and b are false.

313
00:16:11,020 --> 00:16:13,450
And this is the complete
table just in case

314
00:16:13,450 --> 00:16:14,570
you need to reference it.

315
00:16:17,220 --> 00:16:17,720
All right.

316
00:16:17,720 --> 00:16:21,290
So now that we have ways to do
logical-- question right there.

317
00:16:21,290 --> 00:16:22,214
AUDIENCE: [INAUDIBLE]

318
00:16:26,107 --> 00:16:27,440
PROFESSOR: Yeah, great question.

319
00:16:27,440 --> 00:16:29,690
So what does it mean to
compare a string with a string

320
00:16:29,690 --> 00:16:30,620
with the greater than?

321
00:16:30,620 --> 00:16:34,100
So that's just going to compare
them, lexicographically.

322
00:16:34,100 --> 00:16:37,350
So does it come first
in the alphabet?

323
00:16:37,350 --> 00:16:39,440
So we can even test that out.

324
00:16:39,440 --> 00:16:44,490
We can say, is a greater than b?

325
00:16:44,490 --> 00:16:45,115
And it's false.

326
00:16:48,070 --> 00:16:50,153
So b comes later in
the alphabet than a.

327
00:16:53,860 --> 00:16:54,430
OK.

328
00:16:54,430 --> 00:16:56,650
So now we have ways
to do the tests.

329
00:16:56,650 --> 00:17:02,650
So we can add some branching
to our programming toolbox

330
00:17:02,650 --> 00:17:05,140
now that we have
ways to do tests.

331
00:17:05,140 --> 00:17:06,829
This is a map of MIT.

332
00:17:06,829 --> 00:17:10,329
I'm going to go through
sort of a little example

333
00:17:10,329 --> 00:17:15,157
to motivate why we would want
to do branching in our code.

334
00:17:15,157 --> 00:17:17,740
And I think after this lecture,
you'll be able to sort of code

335
00:17:17,740 --> 00:17:20,140
up this algorithm that
I'm going to explain.

336
00:17:20,140 --> 00:17:21,910
So most of us see MIT as a maze.

337
00:17:21,910 --> 00:17:23,470
I first did when I came here.

338
00:17:26,780 --> 00:17:28,280
When I first came
here, obviously, I

339
00:17:28,280 --> 00:17:30,650
signed up for the free
food mailing list.

340
00:17:30,650 --> 00:17:34,340
And MIT, being a maze, I
had no idea where to go,

341
00:17:34,340 --> 00:17:37,140
what the shortest
path was to free food.

342
00:17:37,140 --> 00:17:40,990
So one way to think about
it is all I wanted to do

343
00:17:40,990 --> 00:17:44,630
was get to the free food.

344
00:17:44,630 --> 00:17:47,960
A very simple algorithm to
get there would be to say,

345
00:17:47,960 --> 00:17:49,340
OK, I'm going take
my right hand,

346
00:17:49,340 --> 00:17:51,631
and I'm going to make sure
that my right hand is always

347
00:17:51,631 --> 00:17:53,174
on a wall.

348
00:17:53,174 --> 00:17:55,340
And I'm going to go around
campus with my right hand

349
00:17:55,340 --> 00:17:56,900
always being at a wall.

350
00:17:56,900 --> 00:17:59,150
And eventually, I'll get
to where the free food is.

351
00:17:59,150 --> 00:18:00,800
There might not be
any left, right?

352
00:18:00,800 --> 00:18:03,170
But I'll be there.

353
00:18:03,170 --> 00:18:05,557
So the algorithm is as follows.

354
00:18:05,557 --> 00:18:07,390
If my right hand always
has to be on a wall,

355
00:18:07,390 --> 00:18:10,400
then I'm going to
say, if there's

356
00:18:10,400 --> 00:18:12,350
no wall to my right
side, then I'm

357
00:18:12,350 --> 00:18:14,420
going to go right
until I get to a wall.

358
00:18:17,840 --> 00:18:22,580
Then if there's a wall to my
right, and I can go forward,

359
00:18:22,580 --> 00:18:26,090
I'm just going to
keep going forward.

360
00:18:26,090 --> 00:18:28,400
If I keep going forward, and
there's a wall to my right

361
00:18:28,400 --> 00:18:31,700
and in front of me, I'm going
to turn around and go left.

362
00:18:31,700 --> 00:18:34,490
And then if there's a wall
to my right, in front of me,

363
00:18:34,490 --> 00:18:37,130
and to the left, then I'm going
to turn around and go back.

364
00:18:37,130 --> 00:18:40,550
So with this fairly
simple algorithm,

365
00:18:40,550 --> 00:18:46,840
I just follow the path always
keeping the wall to my right.

366
00:18:46,840 --> 00:18:50,090
And eventually, I would
end up where I need to be.

367
00:18:50,090 --> 00:18:54,110
So notice, I used, just in
plain English, a few key words.

368
00:18:54,110 --> 00:18:57,860
If, otherwise, things like that.

369
00:18:57,860 --> 00:19:01,640
So in programming, we have
those same constructs.

370
00:19:01,640 --> 00:19:03,830
And those same sort
of intuitive words

371
00:19:03,830 --> 00:19:07,250
can be used to tell
Python to do something

372
00:19:07,250 --> 00:19:11,300
or to do something else or to
choose from a different set

373
00:19:11,300 --> 00:19:14,690
of possibilities.

374
00:19:14,690 --> 00:19:16,370
And this way, we
can get the computer

375
00:19:16,370 --> 00:19:18,651
to make decisions for us.

376
00:19:18,651 --> 00:19:20,150
And you might be
thinking, well, you

377
00:19:20,150 --> 00:19:23,150
said that computers can't
make decisions on their own.

378
00:19:23,150 --> 00:19:24,035
It's not.

379
00:19:24,035 --> 00:19:26,600
You, as programmers, are
going to build these decisions

380
00:19:26,600 --> 00:19:28,520
into the program,
and all the computer

381
00:19:28,520 --> 00:19:31,950
is going to do is going to reach
the decision point and say,

382
00:19:31,950 --> 00:19:34,340
OK, this is a decision
point, should I go left

383
00:19:34,340 --> 00:19:35,270
or should I go right?

384
00:19:35,270 --> 00:19:36,890
Or which one do I pick?

385
00:19:36,890 --> 00:19:40,190
And these sort of decisions are
created by you as a programmer.

386
00:19:40,190 --> 00:19:42,290
And the computer just
has to make the decision

387
00:19:42,290 --> 00:19:43,730
and choose a path.

388
00:19:43,730 --> 00:19:45,080
OK.

389
00:19:45,080 --> 00:19:47,720
So in programming, there's
three sort of simple ways

390
00:19:47,720 --> 00:19:50,930
that you can add control
flow to your programs.

391
00:19:50,930 --> 00:19:53,480
And that's making one
decision and choosing

392
00:19:53,480 --> 00:19:57,990
whether to execute something
or execute something else.

393
00:19:57,990 --> 00:20:01,820
The first is a simple if.

394
00:20:01,820 --> 00:20:04,580
And given a program
that just linearly

395
00:20:04,580 --> 00:20:07,490
has statements
that get executed,

396
00:20:07,490 --> 00:20:11,650
whenever I reach
an if statement,

397
00:20:11,650 --> 00:20:13,947
you're going to
check the condition.

398
00:20:13,947 --> 00:20:15,530
The condition is
going to be something

399
00:20:15,530 --> 00:20:18,705
that's going to get evaluated
to either true or false.

400
00:20:21,700 --> 00:20:25,140
So I've reached
the condition here.

401
00:20:25,140 --> 00:20:26,830
And if the condition
is true, then I'm

402
00:20:26,830 --> 00:20:31,510
going to additionally execute
this extra set of expressions.

403
00:20:31,510 --> 00:20:33,160
But if the condition
is false, then I'm

404
00:20:33,160 --> 00:20:35,590
just going to keep going
through the program

405
00:20:35,590 --> 00:20:37,922
and not execute that
extra set of instructions.

406
00:20:41,590 --> 00:20:44,480
How does Python know which
instructions to execute?

407
00:20:44,480 --> 00:20:48,550
They're going to be inside
this what we call code block.

408
00:20:48,550 --> 00:20:51,689
And the code block is
denoted by indentation.

409
00:20:51,689 --> 00:20:53,230
So it's going to be
everything that's

410
00:20:53,230 --> 00:20:58,050
indented is part of
that if code block.

411
00:20:58,050 --> 00:21:01,500
Typically, four
spaces is indentation.

412
00:21:01,500 --> 00:21:02,520
OK.

413
00:21:02,520 --> 00:21:06,970
So that's how you
write code that

414
00:21:06,970 --> 00:21:10,950
decides whether to execute
this extra thing or not.

415
00:21:10,950 --> 00:21:14,410
Now let's say I don't just
want to execute an extra thing,

416
00:21:14,410 --> 00:21:17,500
I want to reach a
point where I say,

417
00:21:17,500 --> 00:21:22,510
I'll either go down this path
or I'll do something else.

418
00:21:22,510 --> 00:21:27,980
That's this right here.

419
00:21:27,980 --> 00:21:34,310
So this if else construct
says this is my code,

420
00:21:34,310 --> 00:21:37,100
I've reached my
decision point here,

421
00:21:37,100 --> 00:21:42,060
if the condition
inside the if is true,

422
00:21:42,060 --> 00:21:45,230
then I'm going to execute maybe
this set of statements here.

423
00:21:48,750 --> 00:21:50,890
But if the condition
is not true,

424
00:21:50,890 --> 00:21:53,860
then I'm not going to execute
that set of statements,

425
00:21:53,860 --> 00:22:00,790
and instead I'm going to
execute under whatever else is.

426
00:22:00,790 --> 00:22:02,400
So using this
construct, I'm either

427
00:22:02,400 --> 00:22:04,890
going to do one set of
expressions or the other,

428
00:22:04,890 --> 00:22:06,870
but never both.

429
00:22:06,870 --> 00:22:08,710
And after I've executed
one or the other,

430
00:22:08,710 --> 00:22:11,065
I'm going to continue on with
just the regular execution

431
00:22:11,065 --> 00:22:11,690
of the program.

432
00:22:20,010 --> 00:22:20,510
OK.

433
00:22:20,510 --> 00:22:22,250
So we're able to either
choose one thing,

434
00:22:22,250 --> 00:22:24,249
choose one thing or
another, but what if we want

435
00:22:24,249 --> 00:22:27,570
to have more than one choice?

436
00:22:27,570 --> 00:22:31,670
So if some number is equal
to zero, I want to do this.

437
00:22:31,670 --> 00:22:33,530
If it's equal to 1,
I want to do this.

438
00:22:33,530 --> 00:22:36,260
If it's equal to 2, I want
to do this, and so on.

439
00:22:36,260 --> 00:22:39,020
That's where this
last one comes in.

440
00:22:39,020 --> 00:22:45,740
And we introduced this other
key word here called elif.

441
00:22:45,740 --> 00:22:49,310
So that stands for
short form for else if.

442
00:22:49,310 --> 00:22:53,250
So first we check if
this condition is true.

443
00:22:53,250 --> 00:22:54,890
So we're going
through our program,

444
00:22:54,890 --> 00:22:56,990
we've reached our
decision point,

445
00:22:56,990 --> 00:22:59,900
if the condition is true,
we're going to execute maybe

446
00:22:59,900 --> 00:23:01,280
this set of instructions.

447
00:23:04,320 --> 00:23:06,480
If the condition is
not true, maybe we'll

448
00:23:06,480 --> 00:23:09,550
check-- if the
condition is not true,

449
00:23:09,550 --> 00:23:11,940
we will check this
next condition.

450
00:23:11,940 --> 00:23:14,802
That's part of the
elif right here.

451
00:23:14,802 --> 00:23:16,260
And if that one's
true, we're going

452
00:23:16,260 --> 00:23:18,720
to execute a different
set of instructions.

453
00:23:18,720 --> 00:23:21,264
You can have more than one elif.

454
00:23:21,264 --> 00:23:22,680
And depending on
which one's true,

455
00:23:22,680 --> 00:23:25,950
you're going to execute a
different set of instructions.

456
00:23:25,950 --> 00:23:28,470
And then this last else
is sort of a catch all

457
00:23:28,470 --> 00:23:31,510
where if none of the previous
conditions were true,

458
00:23:31,510 --> 00:23:35,100
then just do this last
set of expressions.

459
00:23:35,100 --> 00:23:38,190
So in this case, you're
going to choose between one

460
00:23:38,190 --> 00:23:40,680
of these three-- one
of these four roots,

461
00:23:40,680 --> 00:23:43,156
or however many you have.

462
00:23:43,156 --> 00:23:45,030
And then when you're
done making your choice,

463
00:23:45,030 --> 00:23:47,831
you're going to execute the
remaining set of instructions.

464
00:23:51,270 --> 00:23:54,390
So the way this works is if
more than one condition is true,

465
00:23:54,390 --> 00:23:57,960
you're actually just going
to enter one of them.

466
00:23:57,960 --> 00:24:01,020
And you're going to enter the
very first one that's true.

467
00:24:01,020 --> 00:24:02,940
So you're never going
to enter more than one

468
00:24:02,940 --> 00:24:05,640
of these code blocks.

469
00:24:05,640 --> 00:24:08,220
You always enter one, and
you enter the first one

470
00:24:08,220 --> 00:24:09,890
that evaluates to true.

471
00:24:15,840 --> 00:24:19,609
So notice that we denoted
code blocks using indentation.

472
00:24:19,609 --> 00:24:21,150
And that's actually
one of the things

473
00:24:21,150 --> 00:24:22,910
that I really like about Python.

474
00:24:22,910 --> 00:24:26,060
It sort of forces you to
write pretty code and nice

475
00:24:26,060 --> 00:24:31,880
looking code and just
code that's very readable.

476
00:24:31,880 --> 00:24:36,110
And that forces you to indent
everything that's a code block.

477
00:24:36,110 --> 00:24:39,020
So you can easily see sort of
where the flow of control is

478
00:24:39,020 --> 00:24:44,660
and where decision making
points are and things like that.

479
00:24:44,660 --> 00:24:49,490
So in this particular example,
we have one if statement here,

480
00:24:49,490 --> 00:24:51,525
and it checks if two
variables are equal.

481
00:24:55,320 --> 00:24:58,710
And we have an if, elif, else.

482
00:24:58,710 --> 00:25:01,290
And in this example, we're
going to enter either this code

483
00:25:01,290 --> 00:25:04,230
block or this one or
this one, depending

484
00:25:04,230 --> 00:25:06,120
on the variables of x and y.

485
00:25:06,120 --> 00:25:08,670
And we're only going
into one code block.

486
00:25:08,670 --> 00:25:13,510
And we'll enter the
first one that's true.

487
00:25:13,510 --> 00:25:16,020
Notice you can have
nested conditionals.

488
00:25:16,020 --> 00:25:19,060
So inside this first if,
we have another if here.

489
00:25:22,980 --> 00:25:28,860
And this inner if is only going
to be checked when we enter

490
00:25:28,860 --> 00:25:30,440
the first-- this outter if.

491
00:25:36,590 --> 00:25:39,220
I do want to make
one point, though.

492
00:25:39,220 --> 00:25:41,860
So sometimes, you might forget
to do the double equals sign

493
00:25:41,860 --> 00:25:46,210
when you are checking for
equality, and that's OK.

494
00:25:46,210 --> 00:25:48,190
If you just use one
equals sign, Python's

495
00:25:48,190 --> 00:25:50,950
going to give you an error.

496
00:25:50,950 --> 00:25:53,750
And it's going to
say syntax error,

497
00:25:53,750 --> 00:25:55,780
and it's going to
highlight this line.

498
00:25:55,780 --> 00:25:58,690
And then you're going to know
that there's a mistake there.

499
00:25:58,690 --> 00:26:00,340
And you should be
using equality,

500
00:26:00,340 --> 00:26:01,798
because it doesn't
make sense to be

501
00:26:01,798 --> 00:26:05,330
using-- to assign-- to be making
an assignment inside the if.

502
00:26:12,476 --> 00:26:13,850
So we've learned
about branching.

503
00:26:13,850 --> 00:26:17,150
And we know about conditionals.

504
00:26:17,150 --> 00:26:22,760
Let's try to apply
this to a little game.

505
00:26:22,760 --> 00:26:24,980
And spoiler, we
won't be able to.

506
00:26:24,980 --> 00:26:27,020
We'll have to learn
about a new thing.

507
00:26:27,020 --> 00:26:29,300
But back in the 1980s,
there was the Legend

508
00:26:29,300 --> 00:26:33,350
of Zelda-- cool
graphics-- where there was

509
00:26:33,350 --> 00:26:36,410
a scene with the lost woods.

510
00:26:36,410 --> 00:26:40,910
Oversimplification if
anyone's a Zelda die hard fan.

511
00:26:40,910 --> 00:26:45,230
But the basic idea was
if you entered the woods,

512
00:26:45,230 --> 00:26:47,520
you entered from the
left to the right.

513
00:26:47,520 --> 00:26:49,850
And then as long as
you kept going right,

514
00:26:49,850 --> 00:26:53,360
it would show you the same
screen over and over again.

515
00:26:53,360 --> 00:26:56,030
And the trick was you
just had to go backward,

516
00:26:56,030 --> 00:26:58,460
and then you'd exit the woods.

517
00:26:58,460 --> 00:27:00,290
So very simple.

518
00:27:00,290 --> 00:27:04,490
Using what we know so far, we
could sort of code this up.

519
00:27:04,490 --> 00:27:06,080
And we'd say
something like this.

520
00:27:06,080 --> 00:27:08,990
If the user exits right,
then set the background

521
00:27:08,990 --> 00:27:11,250
to the woods background.

522
00:27:11,250 --> 00:27:15,650
Otherwise, set the background
to the exit background.

523
00:27:15,650 --> 00:27:18,920
Now let's say the user-- and
then in the else, we're done.

524
00:27:18,920 --> 00:27:20,900
Let's say the user went right.

525
00:27:20,900 --> 00:27:22,850
Well, you'd show them
the woods background,

526
00:27:22,850 --> 00:27:25,340
and now ask them again,
where do they want to go?

527
00:27:25,340 --> 00:27:26,960
If they exit right,
set the background

528
00:27:26,960 --> 00:27:27,960
to the woods background.

529
00:27:27,960 --> 00:27:31,050
Otherwise, set the background to
the exit background, and so on.

530
00:27:31,050 --> 00:27:35,240
So you notice that there's
sort of no end to this, right?

531
00:27:35,240 --> 00:27:38,452
How many times-- do you
know how many times the user

532
00:27:38,452 --> 00:27:39,410
might keep going right?

533
00:27:39,410 --> 00:27:41,450
They might be really
persistent, right?

534
00:27:41,450 --> 00:27:44,210
And they'll be like maybe
if I go 1,000 times,

535
00:27:44,210 --> 00:27:45,760
I'll get out of the woods.

536
00:27:45,760 --> 00:27:47,660
Maybe 1,001?

537
00:27:47,660 --> 00:27:48,650
Maybe.

538
00:27:48,650 --> 00:27:56,210
So this would probably
be-- who knows how deep?

539
00:27:56,210 --> 00:27:57,492
These nested ifs.

540
00:27:57,492 --> 00:27:58,200
So we don't know.

541
00:28:00,737 --> 00:28:02,570
So with what we know
so far, we can't really

542
00:28:02,570 --> 00:28:04,790
code this cute little game.

543
00:28:04,790 --> 00:28:07,720
But enter loops.

544
00:28:07,720 --> 00:28:11,220
And specifically, a while loop.

545
00:28:11,220 --> 00:28:16,520
So this code here that could
be infinitely number of nested

546
00:28:16,520 --> 00:28:18,710
if statements deep
can be rewritten

547
00:28:18,710 --> 00:28:21,650
using these three lines.

548
00:28:21,650 --> 00:28:24,350
So we say while the
user exits right,

549
00:28:24,350 --> 00:28:26,990
set the background to
the woods background.

550
00:28:26,990 --> 00:28:28,370
And with a while
loop, it's going

551
00:28:28,370 --> 00:28:30,203
to do what we tell it
to do inside the loop,

552
00:28:30,203 --> 00:28:32,310
and then it's going to
check the condition again,

553
00:28:32,310 --> 00:28:34,370
and then it's
going to do what we

554
00:28:34,370 --> 00:28:36,860
say it should do
inside the code block,

555
00:28:36,860 --> 00:28:39,680
and it's going to check
the condition again.

556
00:28:39,680 --> 00:28:42,660
And then when the condition--
as long as a condition is true,

557
00:28:42,660 --> 00:28:45,329
it's going to keep doing
that little loop there.

558
00:28:45,329 --> 00:28:47,120
And as soon as the
condition becomes false,

559
00:28:47,120 --> 00:28:48,770
it's going to stop
doing the loop

560
00:28:48,770 --> 00:28:52,420
and do whatever's
right after the while.

561
00:28:52,420 --> 00:28:53,550
OK.

562
00:28:53,550 --> 00:28:57,510
So that's basically
how a while loop works.

563
00:28:57,510 --> 00:28:58,560
We have while.

564
00:28:58,560 --> 00:29:00,150
That's the key word.

565
00:29:00,150 --> 00:29:01,680
The condition is
something that gets

566
00:29:01,680 --> 00:29:03,910
evaluated to true or false.

567
00:29:03,910 --> 00:29:07,024
And once again, we have a
code block that's indented,

568
00:29:07,024 --> 00:29:08,940
and it tells Python,
these are the expressions

569
00:29:08,940 --> 00:29:11,300
I want to do as long as
the condition is true.

570
00:29:16,350 --> 00:29:18,770
So the condition is true,
you evaluate every expression

571
00:29:18,770 --> 00:29:19,580
in the code block.

572
00:29:19,580 --> 00:29:22,070
When you reach the end of the
expression-- end of the code

573
00:29:22,070 --> 00:29:24,170
block, you check
the condition again.

574
00:29:24,170 --> 00:29:27,230
If it's true still, you
keep doing the expressions.

575
00:29:27,230 --> 00:29:28,990
Check it again, and so on.

576
00:29:32,910 --> 00:29:35,570
So here's a little game.

577
00:29:35,570 --> 00:29:38,090
And with these lines
of code, we were

578
00:29:38,090 --> 00:29:43,160
able-- we can code up
the lost woods of Zelda.

579
00:29:43,160 --> 00:29:46,970
Even worse graphics, by the
way than the original Zelda

580
00:29:46,970 --> 00:29:48,980
is this one that
I coded up here.

581
00:29:48,980 --> 00:29:50,695
So I print out the
following things.

582
00:29:50,695 --> 00:29:51,820
"You're in the Lost Forest.

583
00:29:51,820 --> 00:29:54,500
Go left or right."

584
00:29:54,500 --> 00:29:57,120
And my program's going to say,
"You're in the Lost Forest.

585
00:29:57,120 --> 00:29:58,010
Go left or right."

586
00:29:58,010 --> 00:29:59,730
It's going to get user input.

587
00:29:59,730 --> 00:30:03,890
It's going to say while the
user keeps typing in right,

588
00:30:03,890 --> 00:30:07,280
show them this text,
and ask them again.

589
00:30:07,280 --> 00:30:11,267
So I'm asking them again by
just saying input here again.

590
00:30:11,267 --> 00:30:11,850
And that's it.

591
00:30:11,850 --> 00:30:15,020
That's going to just keep
getting input from the user.

592
00:30:15,020 --> 00:30:18,500
And if the user doesn't type in
right, and maybe types in left,

593
00:30:18,500 --> 00:30:21,230
you're going to exit out of
this loop, and print out,

594
00:30:21,230 --> 00:30:24,870
"You've got out of
the Lost Forest."

595
00:30:24,870 --> 00:30:28,620
So I have to show you this,
because I spent too much time

596
00:30:28,620 --> 00:30:30,750
on it.

597
00:30:30,750 --> 00:30:37,930
But I decided to improve on
the code that's in the slides.

598
00:30:37,930 --> 00:30:41,940
And I've written here ways that
you guys can also improve it.

599
00:30:41,940 --> 00:30:45,190
So if I run my code--
"You're in the Lost Forest.

600
00:30:45,190 --> 00:30:46,000
Go left or right."

601
00:30:46,000 --> 00:30:51,180
So if I say left, then yay,
I got out of the Lost Forest.

602
00:30:51,180 --> 00:30:56,430
But if I go right,
then I'm stuck, right?

603
00:30:56,430 --> 00:30:57,865
I took down some trees.

604
00:30:57,865 --> 00:30:59,490
You can see there's
no more trees here.

605
00:30:59,490 --> 00:31:01,786
I made a table, and
then I flipped it over.

606
00:31:04,920 --> 00:31:07,770
So the expansion to this
if you want to try it out--

607
00:31:07,770 --> 00:31:12,240
I put this in the comments
here-- is try to use a counter.

608
00:31:12,240 --> 00:31:14,820
If the user types in
right the first two times,

609
00:31:14,820 --> 00:31:17,506
just make that a sad face.

610
00:31:17,506 --> 00:31:19,380
But if the user types
in more than two times,

611
00:31:19,380 --> 00:31:24,419
make them cut down some trees
and build a table and flip it.

612
00:31:24,419 --> 00:31:25,960
That's a cute little
expansion if you

613
00:31:25,960 --> 00:31:29,050
want to test yourself to make
sure you are getting loops.

614
00:31:29,050 --> 00:31:30,550
OK.

615
00:31:30,550 --> 00:31:34,760
So so far, we've used while
loops to ask for user input.

616
00:31:34,760 --> 00:31:37,244
And that's actually somewhere
where it makes sense

617
00:31:37,244 --> 00:31:39,160
to use while loops,
because you don't actually

618
00:31:39,160 --> 00:31:43,360
know how many times the user
is going to type in something.

619
00:31:43,360 --> 00:31:47,120
You can use while loops
to keep sort of a counter

620
00:31:47,120 --> 00:31:52,470
and to write code
that counts something.

621
00:31:52,470 --> 00:31:55,200
If you do that, though,
there's two things

622
00:31:55,200 --> 00:31:56,340
you need to take care of.

623
00:31:56,340 --> 00:32:00,600
The first is the
first line here,

624
00:32:00,600 --> 00:32:03,551
which is sort of an
initialization of this loop

625
00:32:03,551 --> 00:32:04,050
counter.

626
00:32:06,860 --> 00:32:09,540
And the second is
this line here,

627
00:32:09,540 --> 00:32:11,815
which is incrementing
your loop counter.

628
00:32:15,630 --> 00:32:17,940
The reason why the
second one is important

629
00:32:17,940 --> 00:32:20,790
is because-- let's look
at our condition here.

630
00:32:20,790 --> 00:32:24,240
So while n is less than five.

631
00:32:24,240 --> 00:32:26,960
If you didn't have
this line here,

632
00:32:26,960 --> 00:32:29,250
you would never increment n.

633
00:32:29,250 --> 00:32:33,030
So every time through the loop,
you just keep printing zeros.

634
00:32:33,030 --> 00:32:34,830
And you would have
an infinite loop.

635
00:32:34,830 --> 00:32:37,170
I do want to show,
though, what--

636
00:32:37,170 --> 00:32:40,530
if you do have an infinite loop,
it's not the end of the world.

637
00:32:40,530 --> 00:32:53,370
So I can say something like--
so while true, print zero.

638
00:32:53,370 --> 00:32:57,180
So this is going to give me an
infinite loop in my program.

639
00:32:57,180 --> 00:32:58,350
And-- whoop.

640
00:33:06,970 --> 00:33:08,110
OK.

641
00:33:08,110 --> 00:33:12,452
So notice it's just printing the
letter p over and over again.

642
00:33:12,452 --> 00:33:13,910
And if I let it go
any longer, it's

643
00:33:13,910 --> 00:33:15,243
going to slow down the computer.

644
00:33:15,243 --> 00:33:18,640
So I'm going to hit
Control-C or Command-C maybe.

645
00:33:18,640 --> 00:33:22,600
And it's going to stop
the program from printing.

646
00:33:22,600 --> 00:33:24,730
So just in case you ever
enter infinite loops

647
00:33:24,730 --> 00:33:28,570
in your programs, just go to
the console and hit Control-C,

648
00:33:28,570 --> 00:33:31,030
and that's going to
stop it from sort

649
00:33:31,030 --> 00:33:34,681
of slowing down the computer.

650
00:33:34,681 --> 00:33:35,180
OK.

651
00:33:35,180 --> 00:33:36,750
So going back to
this example, I was

652
00:33:36,750 --> 00:33:40,560
saying that if you're using
counters-- variables in order

653
00:33:40,560 --> 00:33:42,450
to sort of count up
inside the while loop,

654
00:33:42,450 --> 00:33:44,400
you have to take
care to initialize

655
00:33:44,400 --> 00:33:46,680
a counter variable first.

656
00:33:46,680 --> 00:33:49,170
And then to increment
it, otherwise you'll

657
00:33:49,170 --> 00:33:51,330
enter an infinite loop.

658
00:33:51,330 --> 00:33:53,730
That feels a little bit tedious.

659
00:33:53,730 --> 00:33:57,790
And so there's a shortcut for
doing that exact same thing.

660
00:33:57,790 --> 00:34:00,330
So these four lines,
you can rewrite those

661
00:34:00,330 --> 00:34:04,290
into these two lines right here
using this new type of loop

662
00:34:04,290 --> 00:34:07,060
called a for loop.

663
00:34:07,060 --> 00:34:10,989
So the for loop says, for some
loop variable-- in this case,

664
00:34:10,989 --> 00:34:11,980
I named it n.

665
00:34:11,980 --> 00:34:13,979
You can name it
whatever you want.

666
00:34:13,979 --> 00:34:15,520
In range 5-- we're
going to come back

667
00:34:15,520 --> 00:34:18,350
to what range means in
a little bit-- print n.

668
00:34:22,000 --> 00:34:23,620
So every time through
the loop, you're

669
00:34:23,620 --> 00:34:26,920
going to print out
what the value of n is.

670
00:34:26,920 --> 00:34:31,210
Range 5 actually
creates internally

671
00:34:31,210 --> 00:34:33,940
a sequence of numbers
starting from 0

672
00:34:33,940 --> 00:34:36,949
and going to that
number 5 minus 1.

673
00:34:36,949 --> 00:34:41,949
So the sequence is going
to be 0, 1, 2, 3, and 4.

674
00:34:41,949 --> 00:34:44,199
The first time through the
loop, you're going to say n

675
00:34:44,199 --> 00:34:45,449
is equal to 0.

676
00:34:45,449 --> 00:34:47,080
Or internally, this
is what happens.

677
00:34:47,080 --> 00:34:48,760
N gets the value of 0.

678
00:34:48,760 --> 00:34:51,070
You're going to print n.

679
00:34:51,070 --> 00:34:53,840
Then you're going to
go back to the top.

680
00:34:53,840 --> 00:34:55,239
N gets the value 1.

681
00:34:55,239 --> 00:34:58,120
Then you're going to go
execute whatever is inside.

682
00:34:58,120 --> 00:35:00,232
So you're going to print 1.

683
00:35:00,232 --> 00:35:01,690
Then you're going
to increment that

684
00:35:01,690 --> 00:35:03,400
to the next value
in the sequence.

685
00:35:03,400 --> 00:35:07,600
You're going to print
out 2, and so on.

686
00:35:07,600 --> 00:35:12,000
So this is the general
look of a for loop.

687
00:35:12,000 --> 00:35:16,020
So we have for some
loop variable-- again,

688
00:35:16,020 --> 00:35:21,360
can be named whatever you
want-- in range some number.

689
00:35:21,360 --> 00:35:23,640
Do a bunch of stuff.

690
00:35:23,640 --> 00:35:26,880
And again, these are part
of this for loop code block.

691
00:35:26,880 --> 00:35:29,250
So you should indent
them to tell Python

692
00:35:29,250 --> 00:35:32,580
that these are the things
that you should do.

693
00:35:32,580 --> 00:35:34,350
So when you're using
range some number,

694
00:35:34,350 --> 00:35:38,835
you start out with variable
getting the value 0.

695
00:35:41,980 --> 00:35:44,410
With variable having
value 0, you're

696
00:35:44,410 --> 00:35:47,950
going to execute all
of these expressions.

697
00:35:47,950 --> 00:35:50,690
After all the expressions
in the code block are done,

698
00:35:50,690 --> 00:35:53,930
you're going to go
on to the next value.

699
00:35:53,930 --> 00:35:55,976
So 1.

700
00:35:55,976 --> 00:35:57,850
You're going to execute
all these expressions

701
00:35:57,850 --> 00:36:01,930
with the variable being
value 1, and then so on

702
00:36:01,930 --> 00:36:05,380
and so on until you go
to some num minus 1.

703
00:36:10,450 --> 00:36:13,030
That-- so using
range in that way

704
00:36:13,030 --> 00:36:16,330
is a little bit constraining,
because you're always

705
00:36:16,330 --> 00:36:18,520
going to get values
starting from 0

706
00:36:18,520 --> 00:36:21,570
and ending at some
num minus 1, whatever

707
00:36:21,570 --> 00:36:23,852
is in the parentheses in range.

708
00:36:23,852 --> 00:36:25,810
Sometimes you might want
to write programs that

709
00:36:25,810 --> 00:36:27,532
maybe start at a custom value.

710
00:36:27,532 --> 00:36:28,240
Don't start at 0.

711
00:36:28,240 --> 00:36:29,590
Maybe they start at 5.

712
00:36:29,590 --> 00:36:32,234
Maybe they start at minus 10.

713
00:36:32,234 --> 00:36:34,150
And sometimes you might
want to write programs

714
00:36:34,150 --> 00:36:37,630
that don't go with-- don't
expect the numbers by 1,

715
00:36:37,630 --> 00:36:39,280
but maybe skip
every other number,

716
00:36:39,280 --> 00:36:42,320
go every two numbers, or every
three numbers, and so on.

717
00:36:42,320 --> 00:36:47,570
So you can customize
range to your needs.

718
00:36:47,570 --> 00:36:50,230
The one thing you do need
to give it is the stop.

719
00:36:50,230 --> 00:36:52,420
So if you give it only one
value in the parentheses

720
00:36:52,420 --> 00:36:55,030
that stands for stop.

721
00:36:55,030 --> 00:36:57,550
And by default, start is
going to have the value 0,

722
00:36:57,550 --> 00:37:01,500
and step is going
to have the value 1.

723
00:37:01,500 --> 00:37:04,020
If you give it two things
in the parentheses,

724
00:37:04,020 --> 00:37:06,510
you're giving it start and stop.

725
00:37:06,510 --> 00:37:08,850
So the first being start,
the second being stop.

726
00:37:08,850 --> 00:37:12,905
And step gets this
value of 1 by default.

727
00:37:12,905 --> 00:37:15,030
And if you give it three
things in the parentheses,

728
00:37:15,030 --> 00:37:18,465
you're giving it start,
stop, and step in that order.

729
00:37:22,500 --> 00:37:26,130
And you're always going to
start at the start value

730
00:37:26,130 --> 00:37:30,270
and stop at-- or so you're going
to start at the start value,

731
00:37:30,270 --> 00:37:32,470
and you're going to
go until stop minus 1.

732
00:37:32,470 --> 00:37:34,200
So those are the
sequences of numbers.

733
00:37:36,900 --> 00:37:39,080
So in this first
code right here,

734
00:37:39,080 --> 00:37:40,910
my sum is going to
get the value 0.

735
00:37:40,910 --> 00:37:44,210
And you're going
to have a for loop.

736
00:37:44,210 --> 00:37:46,700
We're going to start
from 7, because we're

737
00:37:46,700 --> 00:37:47,965
giving it two numbers.

738
00:37:47,965 --> 00:37:49,340
And when you give
it two numbers,

739
00:37:49,340 --> 00:37:53,570
it represents start and
stop with step being 1.

740
00:37:53,570 --> 00:37:55,910
So we're starting at 7.

741
00:37:55,910 --> 00:38:00,174
If step is 1, the
next value is 8.

742
00:38:00,174 --> 00:38:01,340
What's the value after that?

743
00:38:05,100 --> 00:38:06,270
If we're incrementing by 1?

744
00:38:09,200 --> 00:38:09,700
9.

745
00:38:12,740 --> 00:38:17,430
And since we're going
until stop minus 1,

746
00:38:17,430 --> 00:38:21,350
we're not actually
going to pick up on 10.

747
00:38:21,350 --> 00:38:23,870
So this loop variable,
i, the very first time

748
00:38:23,870 --> 00:38:28,250
through the loop is going
to have the value 7.

749
00:38:28,250 --> 00:38:33,360
So my sum is going
to be 0 plus 7.

750
00:38:37,510 --> 00:38:40,730
That's everything that's
inside the code block.

751
00:38:40,730 --> 00:38:45,520
The next time through the
loop, i gets the value 8.

752
00:38:45,520 --> 00:38:52,900
So inside the for
loop, my sum gets

753
00:38:52,900 --> 00:38:58,150
whatever the previous value
was, which was 7, plus 8.

754
00:38:58,150 --> 00:39:00,440
OK.

755
00:39:00,440 --> 00:39:04,540
The next time through
the loop, my sum

756
00:39:04,540 --> 00:39:08,260
get the value 7 plus 8 plus 9.

757
00:39:08,260 --> 00:39:10,600
Obviously, replacing that
with the previous value.

758
00:39:10,600 --> 00:39:13,200
So 15.

759
00:39:13,200 --> 00:39:15,841
Since we're not going through
10, that's where we stop.

760
00:39:15,841 --> 00:39:17,590
And we're going to
print out my sum, which

761
00:39:17,590 --> 00:39:19,810
is going to be the value
of 7 plus 8 plus 9.

762
00:39:22,330 --> 00:39:24,790
Yeah?

763
00:39:24,790 --> 00:39:25,290
OK.

764
00:39:25,290 --> 00:39:26,568
Yeah.

765
00:39:26,568 --> 00:39:27,605
AUDIENCE: [INAUDIBLE]

766
00:39:27,605 --> 00:39:29,230
PROFESSOR: Do they
have to be integers?

767
00:39:32,591 --> 00:39:33,590
That's a great question.

768
00:39:33,590 --> 00:39:34,850
We can try that out.

769
00:39:34,850 --> 00:39:38,660
I'm not actually sure right
off the top of my head.

770
00:39:38,660 --> 00:39:46,530
So you can go on Spider and
say-- let's say in this example

771
00:39:46,530 --> 00:39:47,030
here.

772
00:39:52,100 --> 00:39:58,779
So we can say 7.1, 10.3-- yeah.

773
00:39:58,779 --> 00:39:59,945
So they have to be integers.

774
00:40:08,620 --> 00:40:09,250
OK.

775
00:40:09,250 --> 00:40:10,940
So that's that example.

776
00:40:10,940 --> 00:40:13,330
And let's erase that.

777
00:40:13,330 --> 00:40:16,510
In this particular example,
we have start, stop, and step.

778
00:40:16,510 --> 00:40:20,150
And here, we're going
every other value.

779
00:40:20,150 --> 00:40:22,300
So we're starting at 5.

780
00:40:22,300 --> 00:40:25,280
Tell me what the next
value is supposed to be.

781
00:40:25,280 --> 00:40:27,760
If we're taking every other one.

782
00:40:27,760 --> 00:40:35,020
7, and then 9, and then--
are we doing 11 or not?

783
00:40:35,020 --> 00:40:35,950
Excellent.

784
00:40:35,950 --> 00:40:36,460
Nice.

785
00:40:36,460 --> 00:40:37,570
Yeah.

786
00:40:37,570 --> 00:40:41,031
So we're going to
the end minus 1.

787
00:40:41,031 --> 00:40:41,530
OK.

788
00:40:41,530 --> 00:40:43,450
So it's possible
that sometimes you

789
00:40:43,450 --> 00:40:47,439
write code where you might want
to exit out of the loop early.

790
00:40:47,439 --> 00:40:49,480
You don't want to go
through all of the sequences

791
00:40:49,480 --> 00:40:51,040
of your numbers.

792
00:40:51,040 --> 00:40:53,290
Maybe there's a condition
inside there where you just

793
00:40:53,290 --> 00:40:55,409
want to exit the loop early.

794
00:40:55,409 --> 00:40:56,950
Inside the while
loop, maybe you want

795
00:40:56,950 --> 00:41:00,520
to exit the loop before the
condition becomes false.

796
00:41:00,520 --> 00:41:02,980
So that's where the
break statement comes in.

797
00:41:02,980 --> 00:41:06,020
So the break works like this.

798
00:41:06,020 --> 00:41:09,100
It's going to-- as soon
as Python sees this break

799
00:41:09,100 --> 00:41:13,090
statement, it's
going to say, OK,

800
00:41:13,090 --> 00:41:18,160
I'm going to look at whatever
loop I'm currently in.

801
00:41:18,160 --> 00:41:20,350
I'm not evaluating
any expression

802
00:41:20,350 --> 00:41:23,770
after it that comes
within my loop.

803
00:41:23,770 --> 00:41:26,180
And I'm going to
immediately exit the loop.

804
00:41:26,180 --> 00:41:28,870
So I'm going inside
this while, this while,

805
00:41:28,870 --> 00:41:30,610
I'm evaluating this
one expression,

806
00:41:30,610 --> 00:41:33,430
and I suddenly see a break.

807
00:41:33,430 --> 00:41:37,960
Expression b does
not get evaluated.

808
00:41:37,960 --> 00:41:39,970
And break is going
to immediately

809
00:41:39,970 --> 00:41:43,150
exit out of the innermost
loop that it's in.

810
00:41:43,150 --> 00:41:46,540
So this while loop that
has condition 2, that's

811
00:41:46,540 --> 00:41:50,950
the innermost loop that
the break is found in.

812
00:41:50,950 --> 00:41:54,670
So we're going to exit out
of this inner most loop here.

813
00:41:54,670 --> 00:41:57,070
And we're evaluating
expression c.

814
00:41:57,070 --> 00:41:58,900
And notice, we're
evaluating expression c,

815
00:41:58,900 --> 00:42:05,140
because it's-- expression c is
part of the outer while loop.

816
00:42:05,140 --> 00:42:08,470
It's at the same
level as this one.

817
00:42:08,470 --> 00:42:13,820
And these ones are part
of the inner while loop.

818
00:42:13,820 --> 00:42:14,480
OK.

819
00:42:14,480 --> 00:42:16,354
Last thing I want to
say is just a little bit

820
00:42:16,354 --> 00:42:18,410
of a comparison between
for and while loops.

821
00:42:18,410 --> 00:42:21,200
So when would you
use one or the other.

822
00:42:21,200 --> 00:42:23,109
This might be useful
in your problem sets.

823
00:42:23,109 --> 00:42:24,650
So for loops you
usually use when you

824
00:42:24,650 --> 00:42:27,530
know the number of iterations.

825
00:42:27,530 --> 00:42:29,910
While loops are very useful
when, for example, you're

826
00:42:29,910 --> 00:42:32,379
getting user input, and
user input is unpredictable.

827
00:42:32,379 --> 00:42:33,920
You don't know how
many times they're

828
00:42:33,920 --> 00:42:36,685
going to do a certain task.

829
00:42:36,685 --> 00:42:38,060
For both for and
while loops, you

830
00:42:38,060 --> 00:42:40,700
can end out of the loop
early using the break.

831
00:42:40,700 --> 00:42:42,470
The for loop uses this counter.

832
00:42:42,470 --> 00:42:45,380
It's inherent
inside the for loop.

833
00:42:45,380 --> 00:42:48,530
A while loop you can use a
counter in order-- you can use

834
00:42:48,530 --> 00:42:50,840
a while loop to count things.

835
00:42:50,840 --> 00:42:53,766
But you must initialize the
counter before the while loop.

836
00:42:53,766 --> 00:42:56,140
And you have to remember to
increment it within the loop.

837
00:42:56,140 --> 00:43:00,710
Otherwise, you maybe
lead to an infinite loop.

838
00:43:00,710 --> 00:43:04,190
We've seen as the very
first example of a for loop

839
00:43:04,190 --> 00:43:06,900
that the while--
the for loop could

840
00:43:06,900 --> 00:43:08,900
be rewritten as a while
loop, but the vice versa

841
00:43:08,900 --> 00:43:11,160
is not necessarily true.

842
00:43:11,160 --> 00:43:14,450
And the counterexample to
that is just user input.

843
00:43:14,450 --> 00:43:16,430
So you might not
know how many times

844
00:43:16,430 --> 00:43:18,730
you might do a certain task.

845
00:43:18,730 --> 00:43:19,460
All right.

846
00:43:19,460 --> 00:43:20,480
Great.

847
00:43:20,480 --> 00:43:22,420
That's all for today.