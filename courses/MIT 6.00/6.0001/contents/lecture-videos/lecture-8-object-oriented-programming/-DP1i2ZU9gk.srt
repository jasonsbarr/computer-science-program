1
00:00:00,790 --> 00:00:03,190
The following content is
provided under a Creative

2
00:00:03,190 --> 00:00:04,730
Commons license.

3
00:00:04,730 --> 00:00:07,030
Your support will help
MIT OpenCourseWare

4
00:00:07,030 --> 00:00:11,390
continue to offer high quality
educational resources for free.

5
00:00:11,390 --> 00:00:13,990
To make a donation or
view additional materials

6
00:00:13,990 --> 00:00:17,880
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:17,880 --> 00:00:18,840
at ocw.mit.edu.

8
00:00:30,420 --> 00:00:31,670
PROFESSOR: All right everyone.

9
00:00:31,670 --> 00:00:33,950
Let's get started.

10
00:00:33,950 --> 00:00:37,940
So today's lecture and
Wednesday's lecture,

11
00:00:37,940 --> 00:00:39,950
we're going to talk
about this thing called

12
00:00:39,950 --> 00:00:41,430
object oriented programming.

13
00:00:41,430 --> 00:00:43,220
And if you haven't
programmed before,

14
00:00:43,220 --> 00:00:46,550
I think this is a fairly
tough concept to grasp.

15
00:00:46,550 --> 00:00:49,730
But hopefully with
many, many examples

16
00:00:49,730 --> 00:00:55,520
and just by looking at the
code available from lectures,

17
00:00:55,520 --> 00:00:58,210
you'll hopefully get
the hang of it quickly.

18
00:00:58,210 --> 00:01:02,770
So let's talk a little
bit about objects.

19
00:01:02,770 --> 00:01:05,950
And we've seen objects
in Python so far.

20
00:01:05,950 --> 00:01:09,160
Objects are basically
data in Python.

21
00:01:09,160 --> 00:01:12,270
So every object that we've
seen has a certain type.

22
00:01:12,270 --> 00:01:14,185
OK, that we know.

23
00:01:14,185 --> 00:01:16,150
Behind the scenes,
though, every object

24
00:01:16,150 --> 00:01:18,530
has these two additional things.

25
00:01:18,530 --> 00:01:20,280
One is some data representation.

26
00:01:20,280 --> 00:01:26,050
So how Python represents the
object just behind the scenes

27
00:01:26,050 --> 00:01:27,580
and what are different
ways that you

28
00:01:27,580 --> 00:01:31,000
can interact with the object.

29
00:01:31,000 --> 00:01:35,370
So for example, every one of
these is a different object.

30
00:01:35,370 --> 00:01:38,970
For example, this
is the number 1,234.

31
00:01:38,970 --> 00:01:42,120
It's a specific object
that is of type integer.

32
00:01:42,120 --> 00:01:45,940
The number 5 is a different
object that's of type integer

33
00:01:45,940 --> 00:01:46,920
and so on.

34
00:01:46,920 --> 00:01:47,880
We've seen floats.

35
00:01:47,880 --> 00:01:48,990
We've seen strings.

36
00:01:48,990 --> 00:01:50,730
We've seen lists.

37
00:01:50,730 --> 00:01:54,580
Lists and dictionaries are
more complicated objects.

38
00:01:54,580 --> 00:01:55,280
Object types.

39
00:01:55,280 --> 00:01:56,590
Sorry.

40
00:01:56,590 --> 00:01:59,260
But every object has a
type, some sort of way

41
00:01:59,260 --> 00:02:03,169
that it's represented
in Python and some ways

42
00:02:03,169 --> 00:02:04,460
that we can interact with them.

43
00:02:07,020 --> 00:02:07,520
OK.

44
00:02:07,520 --> 00:02:10,190
So the idea behind object
oriented programming

45
00:02:10,190 --> 00:02:13,100
is, first of all, everything
in Python is an object.

46
00:02:13,100 --> 00:02:15,660
We've said that before
and in this lecture

47
00:02:15,660 --> 00:02:17,690
I think we'll really
get at what that means.

48
00:02:17,690 --> 00:02:21,320
So we've seen strings,
integers, dictionaries, lists.

49
00:02:21,320 --> 00:02:22,700
Those are all objects.

50
00:02:22,700 --> 00:02:24,500
When we did functions,
we saw that we

51
00:02:24,500 --> 00:02:27,620
could pass as a parameter
another function.

52
00:02:27,620 --> 00:02:29,740
So functions were also
objects in Python.

53
00:02:29,740 --> 00:02:33,519
So literally everything
in Python is an object.

54
00:02:33,519 --> 00:02:35,810
So what are the kinds of
things we can do with objects?

55
00:02:35,810 --> 00:02:39,230
Well, once you have a type,
you can create a new object

56
00:02:39,230 --> 00:02:40,544
that is of some type.

57
00:02:40,544 --> 00:02:41,960
And you can create
as many objects

58
00:02:41,960 --> 00:02:44,870
as you'd like of that
particular type, right?

59
00:02:44,870 --> 00:02:46,940
An integer 5 and integer 7.

60
00:02:46,940 --> 00:02:50,150
Those all work in a program.

61
00:02:50,150 --> 00:02:52,640
Once you've created
these new objects,

62
00:02:52,640 --> 00:02:54,290
you can manipulate them.

63
00:02:54,290 --> 00:02:56,570
So for a list, for example,
you can append an item

64
00:02:56,570 --> 00:02:59,420
to the end of the list,
you can delete an item,

65
00:02:59,420 --> 00:03:03,980
remove it, concatenate
two lists together.

66
00:03:03,980 --> 00:03:07,021
So that's ways that you
can interact with objects.

67
00:03:07,021 --> 00:03:09,270
And the last thing you can
do is you can destroy them.

68
00:03:09,270 --> 00:03:11,000
So and with lists,
we saw explicitly

69
00:03:11,000 --> 00:03:13,976
that you can delete
elements from a list,

70
00:03:13,976 --> 00:03:15,350
or you can just
forget about them

71
00:03:15,350 --> 00:03:19,380
by reassigning a variable
to another value,

72
00:03:19,380 --> 00:03:21,920
and then at some
point, Python will

73
00:03:21,920 --> 00:03:24,690
collect all of these dead
objects and reclaim the memory.

74
00:03:27,810 --> 00:03:31,790
So let's continue
exploring what objects are.

75
00:03:31,790 --> 00:03:34,320
So let's say I have these
two separate objects.

76
00:03:34,320 --> 00:03:35,450
One is a blue car.

77
00:03:35,450 --> 00:03:36,950
One is a pink car.

78
00:03:36,950 --> 00:03:39,740
So objects are really
data abstractions.

79
00:03:39,740 --> 00:03:43,050
So these two cars can be
created by the same blueprint.

80
00:03:43,050 --> 00:03:43,670
OK?

81
00:03:43,670 --> 00:03:47,400
This is a blueprint for a car
and if an object is a data

82
00:03:47,400 --> 00:03:49,640
abstraction, there's two
things that this abstraction

83
00:03:49,640 --> 00:03:50,940
is going to capture.

84
00:03:50,940 --> 00:03:54,200
The first is some sort
of representation.

85
00:03:54,200 --> 00:03:57,310
What is going to represent the
car, what data represents a car

86
00:03:57,310 --> 00:03:58,540
object?

87
00:03:58,540 --> 00:04:00,400
And the second is
what are ways that we

88
00:04:00,400 --> 00:04:03,080
can interact with the object?

89
00:04:03,080 --> 00:04:06,010
So if we think about
a car blueprint,

90
00:04:06,010 --> 00:04:08,380
some general
representation for a car

91
00:04:08,380 --> 00:04:10,900
could be the number of wheels
it has, the number of doors

92
00:04:10,900 --> 00:04:13,450
it has, maybe its
length, maybe its height,

93
00:04:13,450 --> 00:04:19,579
so this is all part of what
data represents the car.

94
00:04:19,579 --> 00:04:21,149
OK?

95
00:04:21,149 --> 00:04:22,830
The interface for
the car is what

96
00:04:22,830 --> 00:04:24,580
are ways that you
can interact with it.

97
00:04:24,580 --> 00:04:28,115
So for example, you
could paint a car, right?

98
00:04:28,115 --> 00:04:30,720
So you could change its color.

99
00:04:30,720 --> 00:04:34,010
You could have the
car make a noise

100
00:04:34,010 --> 00:04:36,340
and different cars might
make different noises.

101
00:04:36,340 --> 00:04:38,060
Or you can drive the car, right?

102
00:04:38,060 --> 00:04:40,610
So these are all ways that
you can interact with the car.

103
00:04:40,610 --> 00:04:43,130
Whereas the representation
are what makes up the car.

104
00:04:43,130 --> 00:04:48,590
What data abstractions
make up the car.

105
00:04:48,590 --> 00:04:53,630
Let's bring it a little closer
to home by looking at a list.

106
00:04:53,630 --> 00:04:56,990
So we have this data
type of list, right?

107
00:04:56,990 --> 00:05:00,770
We've worked with lists before.

108
00:05:00,770 --> 00:05:05,030
The list with elements 1, 2, 3,
and 4 is a very specific object

109
00:05:05,030 --> 00:05:07,730
that is of type list.

110
00:05:07,730 --> 00:05:09,930
Again, we think about it
in terms of two things.

111
00:05:09,930 --> 00:05:13,500
One is what is the data
representation of the list?

112
00:05:13,500 --> 00:05:16,337
So behind the scenes how
does Python see lists?

113
00:05:16,337 --> 00:05:18,420
And the second is, how do
you interact with lists?

114
00:05:18,420 --> 00:05:20,378
So what are ways that
you can manipulate a list

115
00:05:20,378 --> 00:05:23,260
object once it's created?

116
00:05:23,260 --> 00:05:26,360
So behind the scenes
you have a list, L,

117
00:05:26,360 --> 00:05:29,030
which is going to be made up
of essentially two things.

118
00:05:29,030 --> 00:05:34,280
One is going to be the
value at specific index.

119
00:05:34,280 --> 00:05:34,970
OK?

120
00:05:34,970 --> 00:05:37,250
So at index 0, it has
the value 1, right,

121
00:05:37,250 --> 00:05:39,770
because it's the first
element in the list.

122
00:05:39,770 --> 00:05:43,010
And the second thing
that represents a list

123
00:05:43,010 --> 00:05:47,990
is going to be this second
part, which is a pointer.

124
00:05:47,990 --> 00:05:49,690
And internally this
pointer is going

125
00:05:49,690 --> 00:05:52,420
to tell Python
where is the memory

126
00:05:52,420 --> 00:05:57,610
location in the computer where
you can access the element

127
00:05:57,610 --> 00:05:58,930
index 1.

128
00:05:58,930 --> 00:06:02,320
So it's just essentially
going to be a chain,

129
00:06:02,320 --> 00:06:04,340
going from one
index to the other.

130
00:06:04,340 --> 00:06:08,505
And at the next memory location
you have the value at index 1,

131
00:06:08,505 --> 00:06:09,880
and then you have
another pointer

132
00:06:09,880 --> 00:06:11,620
that takes you to the
location in memory

133
00:06:11,620 --> 00:06:14,440
where the index 2 is located.

134
00:06:14,440 --> 00:06:16,330
And in index 2 you
have the value and then

135
00:06:16,330 --> 00:06:19,490
the next pointer,
and so on and so on.

136
00:06:19,490 --> 00:06:23,750
So this is how Python
internally represents a list.

137
00:06:23,750 --> 00:06:25,560
OK?

138
00:06:25,560 --> 00:06:28,340
How you manipulate lists,
we've done this a lot, right?

139
00:06:28,340 --> 00:06:34,410
You can index into a list, you
can add two lists together,

140
00:06:34,410 --> 00:06:37,160
you can get the length, you can
append to the end of a list,

141
00:06:37,160 --> 00:06:39,860
you can sort a list, reverse a
list, and so many other things,

142
00:06:39,860 --> 00:06:40,700
right?

143
00:06:40,700 --> 00:06:42,116
So these are all
ways that you can

144
00:06:42,116 --> 00:06:45,230
interact with the list object
as soon as you've created it.

145
00:06:45,230 --> 00:06:48,590
So notice both of these,
the internal representation

146
00:06:48,590 --> 00:06:50,270
and how you
manipulate lists, you

147
00:06:50,270 --> 00:06:53,600
don't actually
know internally how

148
00:06:53,600 --> 00:06:55,070
these are represented, right?

149
00:06:55,070 --> 00:06:57,710
How did whoever
wrote the list class

150
00:06:57,710 --> 00:06:59,120
decide to implement a sort.

151
00:06:59,120 --> 00:07:00,440
We don't know.

152
00:07:00,440 --> 00:07:03,380
You also weren't aware of how
these lists were represented

153
00:07:03,380 --> 00:07:03,890
internally.

154
00:07:03,890 --> 00:07:05,270
And you didn't
need to know that.

155
00:07:05,270 --> 00:07:08,300
That's the beauty of
object oriented programming

156
00:07:08,300 --> 00:07:11,140
and having these
data abstractions.

157
00:07:11,140 --> 00:07:13,870
The representations are
private of these objects

158
00:07:13,870 --> 00:07:17,950
and they are only known by what
you can find out how it's done,

159
00:07:17,950 --> 00:07:21,440
but they only should be known
by whoever implemented them.

160
00:07:21,440 --> 00:07:23,140
You, as someone who
uses this class,

161
00:07:23,140 --> 00:07:25,540
doesn't really need to know
how a list is represented

162
00:07:25,540 --> 00:07:27,890
internally in order
to be able to use it

163
00:07:27,890 --> 00:07:30,980
and to write cool
programs with them.

164
00:07:30,980 --> 00:07:32,430
OK?

165
00:07:32,430 --> 00:07:35,930
So just find a
motivation here before we

166
00:07:35,930 --> 00:07:38,600
start writing our
own types of objects

167
00:07:38,600 --> 00:07:41,330
is the advantages of
object oriented programming

168
00:07:41,330 --> 00:07:44,270
is really that
you're able to bundle

169
00:07:44,270 --> 00:07:47,620
this data, bundle some
internal representation,

170
00:07:47,620 --> 00:07:51,760
and some ways to interact with
a program into these packages.

171
00:07:51,760 --> 00:07:55,304
And with these packages,
you can create objects

172
00:07:55,304 --> 00:07:56,720
and all of these
objects are going

173
00:07:56,720 --> 00:07:57,928
to behave the exact same way.

174
00:07:57,928 --> 00:08:00,190
They're going to have the
same internal representation

175
00:08:00,190 --> 00:08:03,260
and the same way that you
can interact with them.

176
00:08:03,260 --> 00:08:08,150
And ultimately, this is going to
contribute to the decomposition

177
00:08:08,150 --> 00:08:11,840
and abstraction ideas
that we talked about when

178
00:08:11,840 --> 00:08:13,227
we talked about functions.

179
00:08:13,227 --> 00:08:14,810
And that means that
you're going to be

180
00:08:14,810 --> 00:08:19,280
able to write code that's a lot
more reusable and a lot easier

181
00:08:19,280 --> 00:08:20,810
to read in the future.

182
00:08:20,810 --> 00:08:23,300
OK.

183
00:08:23,300 --> 00:08:26,150
So just like when we
talked about functions,

184
00:08:26,150 --> 00:08:28,250
we're going to sort
of separate the code

185
00:08:28,250 --> 00:08:34,460
that we talk about today into
code where you implement a data

186
00:08:34,460 --> 00:08:40,309
type and code where you use
an object that you create.

187
00:08:40,309 --> 00:08:40,850
OK?

188
00:08:40,850 --> 00:08:42,641
So remember when we
talked about functions,

189
00:08:42,641 --> 00:08:45,627
you were thinking about it in
terms of writing a function,

190
00:08:45,627 --> 00:08:47,460
so you had to worry
about the details of how

191
00:08:47,460 --> 00:08:49,100
you implement a function.

192
00:08:49,100 --> 00:08:50,750
And then you had
to worry about just

193
00:08:50,750 --> 00:08:52,140
how to use a function, right?

194
00:08:52,140 --> 00:08:55,630
So it's sort of the
same idea today.

195
00:08:55,630 --> 00:09:00,810
So when you're thinking about
implementing your own data

196
00:09:00,810 --> 00:09:04,750
type, you do that with
this thing called a class.

197
00:09:08,500 --> 00:09:10,450
And when you create
a class, you're

198
00:09:10,450 --> 00:09:12,270
basically going to
figure out what name you

199
00:09:12,270 --> 00:09:13,900
want to give your
class and you're

200
00:09:13,900 --> 00:09:16,056
going to find some attributes.

201
00:09:16,056 --> 00:09:17,680
And attributes are
going to be the data

202
00:09:17,680 --> 00:09:21,864
representation and ways that you
can interact with your object.

203
00:09:21,864 --> 00:09:23,530
So you, as the
programmer of this class,

204
00:09:23,530 --> 00:09:25,600
are going to decide
how you want people

205
00:09:25,600 --> 00:09:29,780
to interact with the object
and what data this object

206
00:09:29,780 --> 00:09:32,860
is going to have.

207
00:09:32,860 --> 00:09:35,280
So for example,
someone wrote code

208
00:09:35,280 --> 00:09:37,380
that implements a
list class, right,

209
00:09:37,380 --> 00:09:39,870
and we don't actually
know how that was done.

210
00:09:39,870 --> 00:09:43,180
But we can find out.

211
00:09:43,180 --> 00:09:47,710
So creating the class is
implementing the class

212
00:09:47,710 --> 00:09:49,690
and figuring out data
representation and ways

213
00:09:49,690 --> 00:09:52,270
to interact with the class.

214
00:09:52,270 --> 00:09:55,570
Once that's done, you
can then use your class.

215
00:09:55,570 --> 00:09:57,910
And you use the
class by creating

216
00:09:57,910 --> 00:10:02,164
new instances of the class.

217
00:10:02,164 --> 00:10:03,580
So when you create
a new instance,

218
00:10:03,580 --> 00:10:05,710
you essentially
create a new object

219
00:10:05,710 --> 00:10:09,430
that has the type, the
name of your class.

220
00:10:09,430 --> 00:10:11,560
And you can create as many
objects as you'd like.

221
00:10:11,560 --> 00:10:14,380
You can do all the
operations that you've

222
00:10:14,380 --> 00:10:16,660
defined on the class.

223
00:10:16,660 --> 00:10:18,655
So for example,
someone wrote the code

224
00:10:18,655 --> 00:10:20,530
to implement list class
and then you can just

225
00:10:20,530 --> 00:10:21,920
use the list class like this.

226
00:10:21,920 --> 00:10:25,330
You can create a new list, you
can get the length pf the list,

227
00:10:25,330 --> 00:10:28,320
you can append to the end of
the list, and so on and so on.

228
00:10:33,550 --> 00:10:37,840
So let's start defining
our own types, OK?

229
00:10:37,840 --> 00:10:39,802
So now you're going
to define classes,

230
00:10:39,802 --> 00:10:41,260
you're going to
write classes which

231
00:10:41,260 --> 00:10:45,660
are going to define your
own types of objects.

232
00:10:45,660 --> 00:10:47,750
So for today's
lecture we're going

233
00:10:47,750 --> 00:10:50,240
to look at code
that's going to be

234
00:10:50,240 --> 00:10:53,210
in the context of a
coordinate object.

235
00:10:53,210 --> 00:10:54,860
And a coordinate
object is essentially

236
00:10:54,860 --> 00:11:02,980
going to be an object
that's going to define

237
00:11:02,980 --> 00:11:07,400
a point in an xy plane.

238
00:11:07,400 --> 00:11:12,052
So x, y is going to be a
coordinate in a 2D plane.

239
00:11:12,052 --> 00:11:13,510
So we're going to
write code that's

240
00:11:13,510 --> 00:11:15,885
going to allow us to
define that kind of object.

241
00:11:18,830 --> 00:11:22,804
So the way we do that is
we have to define a class.

242
00:11:22,804 --> 00:11:25,220
So we have to tell Python,
hey, I'm defining my own object

243
00:11:25,220 --> 00:11:26,270
type.

244
00:11:26,270 --> 00:11:28,070
So you do that with
this class key word.

245
00:11:28,070 --> 00:11:31,880
So you say class, then you
say the name of your type.

246
00:11:31,880 --> 00:11:34,460
In this case, we're creating
a type called coordinate.

247
00:11:34,460 --> 00:11:37,170
Just like we had type list,
type string, and so on.

248
00:11:37,170 --> 00:11:40,620
This is going to be a
type called coordinate.

249
00:11:40,620 --> 00:11:42,120
And then in
parentheses here, you

250
00:11:42,120 --> 00:11:44,490
put what the parents
of the class are.

251
00:11:44,490 --> 00:11:48,590
For today's lecture, the
parent of the classes

252
00:11:48,590 --> 00:11:50,480
are going to be this
thing called object,

253
00:11:50,480 --> 00:11:56,180
and object is the very
basic type in Python.

254
00:11:56,180 --> 00:11:58,250
It is the most basic
type in Python.

255
00:11:58,250 --> 00:12:02,210
And it implements things like
being able to assign variables.

256
00:12:02,210 --> 00:12:03,980
So really, really
basic operations

257
00:12:03,980 --> 00:12:06,740
that you can do with objects.

258
00:12:06,740 --> 00:12:08,330
So your coordinate
is therefore going

259
00:12:08,330 --> 00:12:09,945
to be an object in Python.

260
00:12:12,630 --> 00:12:13,130
All right.

261
00:12:13,130 --> 00:12:16,580
So we've told Python we
wanted to define an object.

262
00:12:16,580 --> 00:12:19,470
So inside the class definition
we're going to put attributes.

263
00:12:19,470 --> 00:12:21,820
So what are attributes?

264
00:12:21,820 --> 00:12:24,610
Attributes are going to be
data and procedures that

265
00:12:24,610 --> 00:12:27,000
belong to the class, OK?

266
00:12:27,000 --> 00:12:29,950
Data are going to be the data
representations and procedures

267
00:12:29,950 --> 00:12:33,630
are going to be ways that we
can interact with the object.

268
00:12:33,630 --> 00:12:35,910
The fact that they
belong to the class

269
00:12:35,910 --> 00:12:38,670
means that the data and the
procedures that we write

270
00:12:38,670 --> 00:12:41,490
are only going to work with
an object of this type.

271
00:12:41,490 --> 00:12:42,270
OK.

272
00:12:42,270 --> 00:12:45,102
If you try to use any of
the data or the procedures

273
00:12:45,102 --> 00:12:46,560
with an object of
a different type,

274
00:12:46,560 --> 00:12:51,030
you're going to get an
error because these data

275
00:12:51,030 --> 00:12:56,880
and these attributes will
belong to this particular class.

276
00:12:59,410 --> 00:13:04,810
So the data attributes is,
what is the object, right?

277
00:13:04,810 --> 00:13:07,490
What is the data that
makes up the object?

278
00:13:07,490 --> 00:13:09,220
So for our coordinate
example, it's

279
00:13:09,220 --> 00:13:12,424
going to be the x and y
values for coordinate.

280
00:13:12,424 --> 00:13:13,840
We can decide that
can be ints, we

281
00:13:13,840 --> 00:13:15,910
can decide that we can
let them be floats,

282
00:13:15,910 --> 00:13:19,000
but it's going to have one
value for the x-coordinate

283
00:13:19,000 --> 00:13:20,757
and one value for
the y-coordinate.

284
00:13:23,960 --> 00:13:25,680
So those are data attributes.

285
00:13:25,680 --> 00:13:29,610
And procedure attributes
are better known as methods.

286
00:13:29,610 --> 00:13:32,089
And you can think of a
method as a function.

287
00:13:32,089 --> 00:13:33,630
Except that it's a
function that only

288
00:13:33,630 --> 00:13:37,330
works with this
particular type of object.

289
00:13:37,330 --> 00:13:40,910
So with a coordinate
object, in this case.

290
00:13:40,910 --> 00:13:42,660
So the methods are
going to define how you

291
00:13:42,660 --> 00:13:44,100
can interact with the object.

292
00:13:44,100 --> 00:13:45,875
So in a list, for
example, we've said

293
00:13:45,875 --> 00:13:48,000
that you can append an item
to the end of the list,

294
00:13:48,000 --> 00:13:50,520
we can sort a list,
things like that.

295
00:13:50,520 --> 00:13:52,590
So when you're defining
methods, you're

296
00:13:52,590 --> 00:13:55,120
defining ways that people can
interact with your object.

297
00:13:55,120 --> 00:13:56,800
So for example, for
a coordinate object,

298
00:13:56,800 --> 00:13:59,190
we can say that we can take
the distance between two

299
00:13:59,190 --> 00:14:00,650
coordinate points.

300
00:14:00,650 --> 00:14:01,380
OK?

301
00:14:01,380 --> 00:14:03,463
And that's going to be a
way that you can interact

302
00:14:03,463 --> 00:14:06,360
with two coordinate points.

303
00:14:06,360 --> 00:14:09,630
And just to be clear,
these are going

304
00:14:09,630 --> 00:14:11,130
to belong to this
class, which means

305
00:14:11,130 --> 00:14:14,310
that if you try to use this
distance method on two lists,

306
00:14:14,310 --> 00:14:16,140
for example, you're
going to get an error.

307
00:14:16,140 --> 00:14:19,260
Because this distance method was
only defined to work with two

308
00:14:19,260 --> 00:14:20,531
coordinate type objects.

309
00:14:23,120 --> 00:14:26,680
All right, so let's
carry on and continue

310
00:14:26,680 --> 00:14:28,750
implementing our class.

311
00:14:28,750 --> 00:14:31,300
So we've written this
first line so far,

312
00:14:31,300 --> 00:14:32,640
class coordinate object.

313
00:14:32,640 --> 00:14:35,740
So now let's define attributes.

314
00:14:35,740 --> 00:14:39,640
First thing we're going to
define are data attributes.

315
00:14:39,640 --> 00:14:44,720
Generally you define data
attributes inside this init,

316
00:14:44,720 --> 00:14:47,200
and this is underscore,
underscore, init, underscore,

317
00:14:47,200 --> 00:14:52,510
underscore, and it's a special
method or function in a class.

318
00:14:52,510 --> 00:14:55,997
And the special
method tells Python,

319
00:14:55,997 --> 00:14:57,580
when you implement
the special method,

320
00:14:57,580 --> 00:15:00,940
it tells Python when you first
create an object of this type,

321
00:15:00,940 --> 00:15:03,010
call this method or
call this function.

322
00:15:06,470 --> 00:15:08,080
So how do we do that?

323
00:15:08,080 --> 00:15:09,760
So let's implement it.

324
00:15:09,760 --> 00:15:14,290
So we say df because
it's just a function.

325
00:15:14,290 --> 00:15:17,590
The name is the
special name, init.

326
00:15:17,590 --> 00:15:19,390
And we give it some
parameters, right,

327
00:15:19,390 --> 00:15:22,680
just like any other function.

328
00:15:22,680 --> 00:15:26,250
These last two
parameters are x and y,

329
00:15:26,250 --> 00:15:31,340
which are going to represent how
you create a coordinate object.

330
00:15:31,340 --> 00:15:33,300
So you give it a value
for the x-coordinate

331
00:15:33,300 --> 00:15:36,320
and you give it a value
for the y-coordinate.

332
00:15:36,320 --> 00:15:39,550
The self, however, is
a little bit trickier.

333
00:15:39,550 --> 00:15:42,090
So the self is going
to be a parameter when

334
00:15:42,090 --> 00:15:44,880
you define this
class that represents

335
00:15:44,880 --> 00:15:49,830
a particular instance
of the class.

336
00:15:49,830 --> 00:15:52,500
So we're defining
this coordinate object

337
00:15:52,500 --> 00:15:54,540
in sort of a general way, right?

338
00:15:54,540 --> 00:15:56,670
We don't have a
specific instance

339
00:15:56,670 --> 00:15:59,850
yet because we haven't
created an object yet.

340
00:15:59,850 --> 00:16:02,010
But this self is
going to be sort

341
00:16:02,010 --> 00:16:04,830
of a placeholder for
any sort of instance

342
00:16:04,830 --> 00:16:07,810
when you create the object.

343
00:16:07,810 --> 00:16:10,320
So in the definition
of the class,

344
00:16:10,320 --> 00:16:12,270
whenever you want to
refer to attributes

345
00:16:12,270 --> 00:16:17,530
that belong to an instance,
you have to use self dot.

346
00:16:17,530 --> 00:16:19,330
So this dot notation.

347
00:16:19,330 --> 00:16:26,230
And the dot is going to say
look for a data attribute

348
00:16:26,230 --> 00:16:28,420
x that belongs to this class.

349
00:16:31,240 --> 00:16:34,050
So for methods that
belong to the class,

350
00:16:34,050 --> 00:16:37,314
the first parameter is
always going to be self.

351
00:16:37,314 --> 00:16:38,730
It can be named
anything you want,

352
00:16:38,730 --> 00:16:41,790
but really by convention
it's always named self.

353
00:16:41,790 --> 00:16:44,280
So try to stick to that.

354
00:16:44,280 --> 00:16:46,170
And then any other
parameters beyond it

355
00:16:46,170 --> 00:16:47,910
are going to be just
parameters as you

356
00:16:47,910 --> 00:16:51,190
would put in a normal function.

357
00:16:51,190 --> 00:16:51,871
OK.

358
00:16:51,871 --> 00:16:53,370
In this particular
case, we're going

359
00:16:53,370 --> 00:16:56,340
to choose to initialize
a coordinate object

360
00:16:56,340 --> 00:17:00,810
by two values, one for
the x and one for the y.

361
00:17:00,810 --> 00:17:03,690
And inside this
init method, we're

362
00:17:03,690 --> 00:17:07,839
going to have two assignments.

363
00:17:07,839 --> 00:17:11,579
The first one says,
the x data attribute

364
00:17:11,579 --> 00:17:12,990
of a coordinate object.

365
00:17:12,990 --> 00:17:17,589
I'm going to assign it to
whatever was passed in.

366
00:17:17,589 --> 00:17:20,609
And the y data attribute
for a particular object

367
00:17:20,609 --> 00:17:23,520
is going to be assigned
whatever y was passed in.

368
00:17:30,420 --> 00:17:34,150
Questions so far about
how to write this init?

369
00:17:34,150 --> 00:17:35,000
Yeah, question.

370
00:17:35,000 --> 00:17:35,970
AUDIENCE: [INAUDIBLE]

371
00:17:40,597 --> 00:17:42,430
PROFESSOR: How do you
make sure that x and y

372
00:17:42,430 --> 00:17:44,010
are inits or floats?

373
00:17:44,010 --> 00:17:45,700
So this is something
that you could

374
00:17:45,700 --> 00:17:48,370
write in the specifications,
so the docstring

375
00:17:48,370 --> 00:17:49,570
with the triple quotes.

376
00:17:49,570 --> 00:17:52,900
So whoever uses the
class would then

377
00:17:52,900 --> 00:17:55,930
know that if they do something
outside the specification,

378
00:17:55,930 --> 00:17:58,060
the code might not
work as expected.

379
00:17:58,060 --> 00:18:00,340
Or you could put
in a cert statement

380
00:18:00,340 --> 00:18:03,880
inside the definition
of the init just

381
00:18:03,880 --> 00:18:06,530
to sort of force that.

382
00:18:06,530 --> 00:18:08,470
Force that to be true.

383
00:18:08,470 --> 00:18:09,195
Great question.

384
00:18:09,195 --> 00:18:09,820
Yeah, question.

385
00:18:09,820 --> 00:18:10,760
AUDIENCE: [INAUDIBLE]

386
00:18:14,520 --> 00:18:16,839
PROFESSOR: Does the x,
does this self x and this x

387
00:18:16,839 --> 00:18:17,880
have to be the same name.

388
00:18:17,880 --> 00:18:19,710
The answer is no.

389
00:18:19,710 --> 00:18:22,260
And we're going to
see in class exercise

390
00:18:22,260 --> 00:18:24,160
that you can have
it be different.

391
00:18:27,030 --> 00:18:28,050
OK.

392
00:18:28,050 --> 00:18:28,740
Great.

393
00:18:28,740 --> 00:18:34,260
So this defines the way
that we create an object.

394
00:18:34,260 --> 00:18:39,120
So now we have sort
of a nice class.

395
00:18:39,120 --> 00:18:41,490
It's very simple, but
we can start actually

396
00:18:41,490 --> 00:18:43,897
creating coordinate objects.

397
00:18:43,897 --> 00:18:45,480
So when you create
coordinate objects,

398
00:18:45,480 --> 00:18:48,930
you're creating
instances of the class.

399
00:18:48,930 --> 00:18:52,440
So this line here, C is
equal to coordinate 3,4,

400
00:18:52,440 --> 00:18:55,240
is going to call
the init method.

401
00:18:55,240 --> 00:18:58,180
It's going to call the init
method with x is equal to 3

402
00:18:58,180 --> 00:18:59,380
and y is equal to 4.

403
00:19:01,940 --> 00:19:07,190
I'm just going to go over here
and I wrote this previously,

404
00:19:07,190 --> 00:19:13,980
because notice when we're
creating an object here,

405
00:19:13,980 --> 00:19:16,890
we're only giving
it two parameters.

406
00:19:16,890 --> 00:19:20,190
But in the init method, we
have actually three parameters,

407
00:19:20,190 --> 00:19:21,060
right?

408
00:19:21,060 --> 00:19:22,894
We have these three
parameters here,

409
00:19:22,894 --> 00:19:24,310
but when we're
creating an object,

410
00:19:24,310 --> 00:19:25,950
we only give it two parameters.

411
00:19:25,950 --> 00:19:28,600
And that's OK because
implicitly, Python

412
00:19:28,600 --> 00:19:31,830
is going to say self is going
to be this object C, so just

413
00:19:31,830 --> 00:19:33,317
by default, OK?

414
00:19:33,317 --> 00:19:35,150
So when you're creating
a coordinate object,

415
00:19:35,150 --> 00:19:40,260
you're passing it all the
variables except for self.

416
00:19:44,930 --> 00:19:47,350
So this line here is
going to call the init

417
00:19:47,350 --> 00:19:49,740
and it's going to do every
line inside the init.

418
00:19:49,740 --> 00:19:54,650
So it's going to create
an x data attribute for C,

419
00:19:54,650 --> 00:19:56,930
a y data attribute
for C, and it's

420
00:19:56,930 --> 00:20:01,800
going to assign 3 and 4
to those respectively.

421
00:20:01,800 --> 00:20:05,300
This next line here is
origin equals coordinate 0,

422
00:20:05,300 --> 00:20:08,810
0 creates another object.

423
00:20:08,810 --> 00:20:10,170
OK?

424
00:20:10,170 --> 00:20:13,770
It's another coordinate
object whose value for x is 0

425
00:20:13,770 --> 00:20:16,200
and whose value for y is 0.

426
00:20:16,200 --> 00:20:19,210
So now we have two
coordinate objects.

427
00:20:19,210 --> 00:20:21,540
We can access the
data attributes

428
00:20:21,540 --> 00:20:24,852
using this dot notation and
we've seen that before, right?

429
00:20:24,852 --> 00:20:27,060
When we've worked with lists
we'd say something like,

430
00:20:27,060 --> 00:20:30,130
L dot append, right,
when we create a list.

431
00:20:30,130 --> 00:20:34,830
So the same dot notation can
be used with your own objects

432
00:20:34,830 --> 00:20:37,350
in order to access
data attributes.

433
00:20:37,350 --> 00:20:39,720
So here, this is
going to print 3

434
00:20:39,720 --> 00:20:47,180
because the x value
for object C is 3,

435
00:20:47,180 --> 00:20:49,100
and the next line,
print origin x

436
00:20:49,100 --> 00:20:53,150
is going to print 0 because the
x value for the object origin

437
00:20:53,150 --> 00:20:54,830
is 0.

438
00:20:54,830 --> 00:20:55,780
OK.

439
00:20:55,780 --> 00:20:59,450
So we've created a
coordinate object.

440
00:20:59,450 --> 00:21:01,060
We have to find the
init method so we

441
00:21:01,060 --> 00:21:05,210
have a way to create objects
when we use the class.

442
00:21:05,210 --> 00:21:08,260
And then we can access
the data attributes.

443
00:21:08,260 --> 00:21:11,530
But that's kind of lame, right,
because there isn't anything

444
00:21:11,530 --> 00:21:12,560
cool we can do with it.

445
00:21:12,560 --> 00:21:15,790
There isn't ways to
interact with this object.

446
00:21:15,790 --> 00:21:17,770
So let's add some methods.

447
00:21:17,770 --> 00:21:21,670
Remember methods are going to
be procedural attributes that

448
00:21:21,670 --> 00:21:25,030
allow us to interact
with our object.

449
00:21:25,030 --> 00:21:27,880
Methods are like functions
except that there's

450
00:21:27,880 --> 00:21:30,790
a couple of differences
which you'll see in a moment.

451
00:21:30,790 --> 00:21:33,790
And when you're
calling methods, you're

452
00:21:33,790 --> 00:21:38,380
using the dot operator, like
L dot append, for example,

453
00:21:38,380 --> 00:21:38,920
for lists.

454
00:21:41,810 --> 00:21:45,650
So let's go back to defining
our coordinate class

455
00:21:45,650 --> 00:21:48,240
and let's define
a method for it.

456
00:21:48,240 --> 00:21:50,910
So so far we've defined
that part there,

457
00:21:50,910 --> 00:21:52,440
class coordinate and an init.

458
00:21:52,440 --> 00:21:53,790
So we have that.

459
00:21:53,790 --> 00:21:58,160
So in this slide we're going
to add this method here.

460
00:21:58,160 --> 00:21:59,930
So this method here
is going to say

461
00:21:59,930 --> 00:22:04,280
I'm going to define a
method called distance

462
00:22:04,280 --> 00:22:06,170
and I'm going to pass
in two parameters.

463
00:22:06,170 --> 00:22:08,720
Remember self, the
first parameter,

464
00:22:08,720 --> 00:22:11,330
is always going to be
the instance of an object

465
00:22:11,330 --> 00:22:14,740
that you're going to
perform the operation on.

466
00:22:14,740 --> 00:22:19,630
So pretty much by convention
it's always named self.

467
00:22:22,700 --> 00:22:25,010
And then for this
particular method,

468
00:22:25,010 --> 00:22:26,990
I'm going to give it
another parameter,

469
00:22:26,990 --> 00:22:29,410
and I can name this
whatever I want.

470
00:22:29,410 --> 00:22:31,110
I'm naming it other.

471
00:22:31,110 --> 00:22:34,190
And this is going to represent
the other coordinate object

472
00:22:34,190 --> 00:22:38,142
for which I want to find
the distance from my self.

473
00:22:38,142 --> 00:22:39,600
So here I'm going
to just implement

474
00:22:39,600 --> 00:22:46,320
the Euclidean distance formula,
which is x1 minus x2 squared,

475
00:22:46,320 --> 00:22:50,750
plus Y1 minus Y2 squared,
and square root of all that.

476
00:22:50,750 --> 00:22:54,370
So that's what I'm
doing inside here.

477
00:22:54,370 --> 00:22:56,255
Self and other are
coordinate objects.

478
00:22:59,150 --> 00:23:04,940
Inside this method, I have
to refer to the x data

479
00:23:04,940 --> 00:23:06,890
attributes of each
object if I want

480
00:23:06,890 --> 00:23:11,220
to find the difference between
the 2x values from them.

481
00:23:11,220 --> 00:23:14,270
So that's why I'm doing
self dot x here, right.

482
00:23:14,270 --> 00:23:17,240
If I just did x, I would be
accessing just some variable

483
00:23:17,240 --> 00:23:22,250
named x in a program which
actually isn't even defined.

484
00:23:22,250 --> 00:23:26,984
So you always have to
refer when as we're

485
00:23:26,984 --> 00:23:28,400
thinking about
classes, you always

486
00:23:28,400 --> 00:23:30,770
have to refer to
whose data attribute

487
00:23:30,770 --> 00:23:32,870
do you want to access?

488
00:23:32,870 --> 00:23:35,000
In this case, I want
to access the x data

489
00:23:35,000 --> 00:23:38,840
attribute of my self, and I
want to subtract the x data

490
00:23:38,840 --> 00:23:41,270
attribute of this
other coordinate,

491
00:23:41,270 --> 00:23:45,740
square that, same for y,
square that, and then add those

492
00:23:45,740 --> 00:23:48,320
and take the square
root of that.

493
00:23:48,320 --> 00:23:51,110
So notice this method is pretty
much like a function, right?

494
00:23:51,110 --> 00:23:54,830
You have DF, some name,
it takes in parameters.

495
00:23:54,830 --> 00:23:57,920
It does some stuff and
then it returns a value.

496
00:23:57,920 --> 00:24:01,270
The only difference is the
fact that you have a self here

497
00:24:01,270 --> 00:24:04,850
as the first thing and
the fact that you always

498
00:24:04,850 --> 00:24:07,760
have to be conscious about
whose data attributes

499
00:24:07,760 --> 00:24:08,510
you're accessing.

500
00:24:12,140 --> 00:24:14,080
So you have to use the
dot notation in order

501
00:24:14,080 --> 00:24:17,840
to decide whose data
attributes you want access.

502
00:24:17,840 --> 00:24:21,222
So we've defined the
method here, distance.

503
00:24:21,222 --> 00:24:22,680
So this is in the
class definition.

504
00:24:22,680 --> 00:24:25,170
Now how do we use it?

505
00:24:25,170 --> 00:24:28,120
So let's assume that the
definition of distance

506
00:24:28,120 --> 00:24:29,000
is up here.

507
00:24:29,000 --> 00:24:32,320
I didn't include the code.

508
00:24:32,320 --> 00:24:34,560
But really all you need
to know is what it takes.

509
00:24:34,560 --> 00:24:37,060
It takes a self and an other.

510
00:24:37,060 --> 00:24:39,490
So when you want
to use this method

511
00:24:39,490 --> 00:24:42,130
to figure out a distance
between two coordinate objects,

512
00:24:42,130 --> 00:24:43,490
this is how you do it.

513
00:24:43,490 --> 00:24:47,110
So the first line, I create
one coordinate object.

514
00:24:47,110 --> 00:24:50,320
Second line, I create
another coordinate object.

515
00:24:50,320 --> 00:24:52,630
First one is named C, the
second one is named 0.

516
00:24:52,630 --> 00:24:55,890
These are two separate objects.

517
00:24:55,890 --> 00:25:00,410
And I'm going to
find the distance.

518
00:25:00,410 --> 00:25:03,400
And I want to first
call it on one object,

519
00:25:03,400 --> 00:25:07,340
so I'm going to say C dot,
so I'm using the dot notation

520
00:25:07,340 --> 00:25:14,740
to call the method
distance on object C.

521
00:25:14,740 --> 00:25:18,124
So Python says this object
C is of type coordinate.

522
00:25:18,124 --> 00:25:19,540
It's going to look
up at the class

523
00:25:19,540 --> 00:25:20,770
coordinate that you defined.

524
00:25:20,770 --> 00:25:23,350
It's going to find this
method called distance

525
00:25:23,350 --> 00:25:26,290
and then it's going to say
what parameters does it take?

526
00:25:26,290 --> 00:25:29,620
So it takes another parameter,
right, for the other

527
00:25:29,620 --> 00:25:31,690
and then, in the
parentheses, I just

528
00:25:31,690 --> 00:25:35,590
have to give it this
other perimeter.

529
00:25:35,590 --> 00:25:37,870
An easier way to
see what happens

530
00:25:37,870 --> 00:25:42,910
is by looking at what this
line here is equivalent to.

531
00:25:46,000 --> 00:25:48,560
So the third line
here prints C dot

532
00:25:48,560 --> 00:25:51,659
distance 0 is equivalent
to this one on the right.

533
00:25:51,659 --> 00:25:53,200
And this one on the
right essentially

534
00:25:53,200 --> 00:25:57,620
says, what's the
name of the class,

535
00:25:57,620 --> 00:26:01,680
dot, dot notation, what's
the method you want to call,

536
00:26:01,680 --> 00:26:03,900
and then in
parentheses you give it

537
00:26:03,900 --> 00:26:06,330
all of the variables
including self.

538
00:26:06,330 --> 00:26:06,930
OK.

539
00:26:06,930 --> 00:26:09,750
So in this case you're
explicitly telling Python

540
00:26:09,750 --> 00:26:16,030
that self is C and other is 0.

541
00:26:16,030 --> 00:26:22,080
So this is a little bit easier
to understand, like that.

542
00:26:22,080 --> 00:26:25,320
But it's a little cumbersome
because you always

543
00:26:25,320 --> 00:26:27,900
have to write coordinate dot,
coordinate dot, coordinate dot,

544
00:26:27,900 --> 00:26:29,525
for every data
attribute you might want

545
00:26:29,525 --> 00:26:31,630
to access, for every
procedural attribute you

546
00:26:31,630 --> 00:26:34,110
might want to access.

547
00:26:34,110 --> 00:26:36,960
So by convention,
it's a lot easier

548
00:26:36,960 --> 00:26:40,010
to do the one on the left.

549
00:26:40,010 --> 00:26:42,860
And as I mentioned,
Python implicitly says,

550
00:26:42,860 --> 00:26:45,490
if you're doing the
one on the left,

551
00:26:45,490 --> 00:26:47,900
you can call this method
on a particular object

552
00:26:47,900 --> 00:26:49,900
and it's going to look
up the type of the object

553
00:26:49,900 --> 00:26:52,900
and it's going to essentially
convert this on the left

554
00:26:52,900 --> 00:26:54,841
to the one on the right.

555
00:26:54,841 --> 00:26:56,590
And this is what you've
been using so far.

556
00:26:56,590 --> 00:26:59,620
So when you create a list,
you say L is equal to 1, 2,

557
00:26:59,620 --> 00:27:05,160
and then you say L.append,
you know, 3 or whatever.

558
00:27:05,160 --> 00:27:09,680
So we've been using this
notation on the left

559
00:27:09,680 --> 00:27:14,240
pretty much from the
beginning of class.

560
00:27:14,240 --> 00:27:17,280
So we have a
coordinate class, we

561
00:27:17,280 --> 00:27:19,110
can create a
coordinate object, we

562
00:27:19,110 --> 00:27:22,116
can get the distance
between two objects.

563
00:27:22,116 --> 00:27:23,490
As you're using
the class, if you

564
00:27:23,490 --> 00:27:25,860
wanted to use this
coordinate class,

565
00:27:25,860 --> 00:27:29,580
and you were maybe debugging
at some point, a lot of you

566
00:27:29,580 --> 00:27:32,160
probably use print as a
debug statement, right?

567
00:27:32,160 --> 00:27:37,799
And maybe you want to print the
value of a coordinate object.

568
00:27:37,799 --> 00:27:39,340
So if you create a
coordinate object,

569
00:27:39,340 --> 00:27:41,620
C is equal to
coordinate 3, 4, right?

570
00:27:41,620 --> 00:27:43,400
That's what we've done so far.

571
00:27:43,400 --> 00:27:48,100
If you print C, you
get this funny message.

572
00:27:48,100 --> 00:27:49,570
Very uninformative, right?

573
00:27:49,570 --> 00:27:53,800
It basically says, well,
C is an object of type

574
00:27:53,800 --> 00:28:00,289
coordinate at this memory
location in the computer.

575
00:28:00,289 --> 00:28:02,080
Which is not what you
wanted at all, right?

576
00:28:02,080 --> 00:28:04,990
Maybe you wanted to know what
the values for x and y were.

577
00:28:04,990 --> 00:28:08,190
That would be a lot
more informative.

578
00:28:08,190 --> 00:28:14,260
So by default, when you
create your own type, when

579
00:28:14,260 --> 00:28:15,820
you print the
object of that type,

580
00:28:15,820 --> 00:28:17,620
Python tells you this
sort of information

581
00:28:17,620 --> 00:28:19,670
which is not what you want.

582
00:28:19,670 --> 00:28:21,190
So what you need
to do is you need

583
00:28:21,190 --> 00:28:24,190
to define your own
method that tells

584
00:28:24,190 --> 00:28:27,460
Python what to do
when you call print

585
00:28:27,460 --> 00:28:31,000
on an object of this type.

586
00:28:31,000 --> 00:28:34,210
So this is going to be
a special method, just

587
00:28:34,210 --> 00:28:36,760
like init is, because
it starts and ends

588
00:28:36,760 --> 00:28:39,650
with double underscores.

589
00:28:39,650 --> 00:28:42,700
And the name of the method is
underscore, underscore, str,

590
00:28:42,700 --> 00:28:44,380
underscore, underscore.

591
00:28:44,380 --> 00:28:48,550
And if you define this method in
your class, that tells Python,

592
00:28:48,550 --> 00:28:51,010
hey, when you see a
print statement that's

593
00:28:51,010 --> 00:28:54,250
on an object of type
coordinate, call this method,

594
00:28:54,250 --> 00:28:58,750
look what it does, and do
everything that's inside it.

595
00:28:58,750 --> 00:29:02,440
And you can choose to make
it do whatever you want

596
00:29:02,440 --> 00:29:05,920
inside your definition of str.

597
00:29:05,920 --> 00:29:08,620
In this case, let's say when
we print a coordinate object,

598
00:29:08,620 --> 00:29:11,290
we're going to print its
x and y values surrounded

599
00:29:11,290 --> 00:29:13,120
by angle brackets.

600
00:29:13,120 --> 00:29:14,950
That seems reasonable, right?

601
00:29:14,950 --> 00:29:20,240
So then from now on when you
print coordinate objects,

602
00:29:20,240 --> 00:29:22,090
you're going to see
things like this, which

603
00:29:22,090 --> 00:29:25,660
is a lot more informative.

604
00:29:25,660 --> 00:29:27,630
So how do we define this?

605
00:29:27,630 --> 00:29:32,610
So so far we've defined
all that and the last part

606
00:29:32,610 --> 00:29:35,030
is going to be new.

607
00:29:35,030 --> 00:29:37,150
So we define the init
and the distance,

608
00:29:37,150 --> 00:29:38,335
and let's define this str.

609
00:29:42,170 --> 00:29:45,830
So underscore, underscore,
str, underscore, underscore, is

610
00:29:45,830 --> 00:29:47,770
a method.

611
00:29:47,770 --> 00:29:51,060
It's only going to take self
because you're just calling

612
00:29:51,060 --> 00:29:54,030
print on the object itself.

613
00:29:54,030 --> 00:29:57,550
There's no other
parameters to it.

614
00:29:57,550 --> 00:30:03,100
Str has to return a string,
and in this particular case,

615
00:30:03,100 --> 00:30:05,380
we're going to return
the string that's

616
00:30:05,380 --> 00:30:10,040
the angle brackets concatenated
with the x value of the object,

617
00:30:10,040 --> 00:30:13,360
self.x, concatenated
with a comma,

618
00:30:13,360 --> 00:30:17,080
concatenated with the y value
of this particular instance

619
00:30:17,080 --> 00:30:19,965
of an object, self.y,
and then concatenated

620
00:30:19,965 --> 00:30:20,965
with the angle brackets.

621
00:30:23,720 --> 00:30:26,510
So now any time you have
print on an object of type

622
00:30:26,510 --> 00:30:29,660
coordinate, you're going to
call this special method str,

623
00:30:29,660 --> 00:30:32,480
if it's implemented
in your code.

624
00:30:32,480 --> 00:30:33,230
Any questions?

625
00:30:37,570 --> 00:30:38,070
OK.

626
00:30:41,460 --> 00:30:46,235
So let's try to wrap our
head around types and classes

627
00:30:46,235 --> 00:30:47,526
because we've seen a lot today.

628
00:30:50,780 --> 00:30:54,240
Let's create a
coordinate object,

629
00:30:54,240 --> 00:31:00,290
assign it 3, 4, as we have been,
and assign it to variable C.

630
00:31:00,290 --> 00:31:04,760
We've implemented the str
method, so when we print C,

631
00:31:04,760 --> 00:31:07,430
it's going to print out this
nice three comma for our angle

632
00:31:07,430 --> 00:31:07,930
brackets.

633
00:31:11,140 --> 00:31:13,120
If we print the type
of C, this is actually

634
00:31:13,120 --> 00:31:17,550
going to give us class main
coordinate, which tells us

635
00:31:17,550 --> 00:31:27,770
that C is going to
be an object that

636
00:31:27,770 --> 00:31:30,564
is of type class coordinate.

637
00:31:33,370 --> 00:31:37,500
If we look at
coordinate as a class,

638
00:31:37,500 --> 00:31:40,320
if we print what coordinate is,
coordinate is a class, right?

639
00:31:40,320 --> 00:31:42,840
So this is what Python tells
us, if we print coordinate,

640
00:31:42,840 --> 00:31:46,730
it's a class named coordinate.

641
00:31:46,730 --> 00:31:48,480
And if we print the
type of a coordinate,

642
00:31:48,480 --> 00:31:50,400
well that's just
going to be a type.

643
00:31:50,400 --> 00:31:51,720
So class is going to be a type.

644
00:31:51,720 --> 00:31:53,428
So you're defining
the type of an object.

645
00:31:56,770 --> 00:32:01,950
If you'd like to figure out
whether a particular object is

646
00:32:01,950 --> 00:32:03,800
an instance of a
particular class,

647
00:32:03,800 --> 00:32:07,080
you use this special
function called is instance.

648
00:32:07,080 --> 00:32:10,320
So if you print is instance
C comma coordinate,

649
00:32:10,320 --> 00:32:13,710
this is going to print true
because C is an object that

650
00:32:13,710 --> 00:32:15,571
is of type coordinate.

651
00:32:23,430 --> 00:32:26,110
Couple more words on
these special operators.

652
00:32:26,110 --> 00:32:27,720
So these special
operators allow you

653
00:32:27,720 --> 00:32:31,770
to customize your classes which
can add some cool functionality

654
00:32:31,770 --> 00:32:33,410
to them.

655
00:32:33,410 --> 00:32:36,800
So these special
operators are going

656
00:32:36,800 --> 00:32:39,710
to be things like
addition, subtraction,

657
00:32:39,710 --> 00:32:42,140
using the equal equal sign,
greater than, less than,

658
00:32:42,140 --> 00:32:44,690
length and so on and so on.

659
00:32:44,690 --> 00:32:48,140
So just like str,
if you implement

660
00:32:48,140 --> 00:32:52,400
any of these in your classes,
this is going to tell Python.

661
00:32:52,400 --> 00:32:56,310
So for example, if we've
implemented this underscore,

662
00:32:56,310 --> 00:33:00,590
underscore, add, underscore,
underscore in our class,

663
00:33:00,590 --> 00:33:01,970
this is going to
tell Python when

664
00:33:01,970 --> 00:33:04,700
you use this plus operator
between two objects of type

665
00:33:04,700 --> 00:33:08,990
coordinate to call this method.

666
00:33:08,990 --> 00:33:10,850
If you have not
implemented this method

667
00:33:10,850 --> 00:33:13,070
and you try to add two
objects of type coordinate,

668
00:33:13,070 --> 00:33:15,110
you're going to get an error
because Python doesn't actually

669
00:33:15,110 --> 00:33:16,610
know right off
the bat how to add

670
00:33:16,610 --> 00:33:18,260
two coordinate objects, right?

671
00:33:18,260 --> 00:33:20,454
You have to tell
it how to do that.

672
00:33:20,454 --> 00:33:22,370
And you tell it how to
do that by implementing

673
00:33:22,370 --> 00:33:26,360
this special method.

674
00:33:26,360 --> 00:33:27,350
Same with subtract.

675
00:33:27,350 --> 00:33:28,550
Same with equals.

676
00:33:28,550 --> 00:33:31,740
So if you want to figure out
whether two objects are equal.

677
00:33:31,740 --> 00:33:35,180
And when you implement these
methods in your own class,

678
00:33:35,180 --> 00:33:39,204
you can decide exactly
what you want to do.

679
00:33:39,204 --> 00:33:41,370
So what happens when you
add two coordinate objects?

680
00:33:41,370 --> 00:33:43,849
Do you just add the x values,
do you just add the y values,

681
00:33:43,849 --> 00:33:45,390
do you get them both
together, do you

682
00:33:45,390 --> 00:33:48,210
do whatever you'd like to do.

683
00:33:48,210 --> 00:33:51,400
And then you document
what you've decided.

684
00:33:51,400 --> 00:33:54,256
So let's create a
fraction object.

685
00:33:54,256 --> 00:33:55,630
So we've looked
at coordinate, we

686
00:33:55,630 --> 00:33:58,400
saw sort of a higher
level car object.

687
00:33:58,400 --> 00:34:01,800
Let's look at a fraction object.

688
00:34:01,800 --> 00:34:04,800
Fraction object
is going to be, is

689
00:34:04,800 --> 00:34:09,159
going represent a number that's
going to be a numerator slash

690
00:34:09,159 --> 00:34:11,400
denominator.

691
00:34:11,400 --> 00:34:11,900
OK.

692
00:34:11,900 --> 00:34:14,130
So that's going to
be a fraction object.

693
00:34:14,130 --> 00:34:17,810
So the way I've decided to
internally represent a fraction

694
00:34:17,810 --> 00:34:20,810
object is with two numbers.

695
00:34:20,810 --> 00:34:24,020
And I've decided that I
will not let them be floats.

696
00:34:24,020 --> 00:34:29,710
They have to be integers,
hence the assert over here.

697
00:34:29,710 --> 00:34:31,750
So inside the init,
I've decided I'm

698
00:34:31,750 --> 00:34:37,719
going to represent my
fracture with two numbers, one

699
00:34:37,719 --> 00:34:41,880
for the numerator and
one for the denominator.

700
00:34:41,880 --> 00:34:43,460
So when I create
a fraction object,

701
00:34:43,460 --> 00:34:48,050
I'm going to pass in a
numerator and a denominator.

702
00:34:48,050 --> 00:34:51,050
And a particular
instance is going

703
00:34:51,050 --> 00:34:53,510
to have self dot
numerator and self dot

704
00:34:53,510 --> 00:34:55,780
denominator as its
data attributes

705
00:34:55,780 --> 00:34:59,995
and I'm assigning those to be
whatever's passed into my init.

706
00:35:03,250 --> 00:35:07,420
Since I plan on debugging this
code maybe possibly sometime

707
00:35:07,420 --> 00:35:10,900
in the future, I'm also
including an str method

708
00:35:10,900 --> 00:35:20,350
and the str method is going
to print a nice looking string

709
00:35:20,350 --> 00:35:22,750
that's going to represent
the numerator, and then

710
00:35:22,750 --> 00:35:26,566
a slash, and then
the denominator.

711
00:35:30,300 --> 00:35:33,650
And then I've also implemented
some other special methods.

712
00:35:33,650 --> 00:35:35,570
How do I add two fractions?

713
00:35:35,570 --> 00:35:38,180
How do I subtract two fractions?

714
00:35:38,180 --> 00:35:42,410
And how do I convert
a fraction to a float?

715
00:35:42,410 --> 00:35:44,120
The add and subtract
are almost the same,

716
00:35:44,120 --> 00:35:48,190
so let's look at the
add for the moment.

717
00:35:48,190 --> 00:35:49,450
How do we add two fractions?

718
00:35:52,520 --> 00:35:59,410
We're going to take self, which
is the instance of an object

719
00:35:59,410 --> 00:36:02,210
that I want to do
the add operation on,

720
00:36:02,210 --> 00:36:03,710
and we're going to
take other, which

721
00:36:03,710 --> 00:36:05,860
is the other
instance of an object

722
00:36:05,860 --> 00:36:09,130
that I want to do the
operation on, so the addition,

723
00:36:09,130 --> 00:36:11,350
and I'm going to
figure out the new top.

724
00:36:11,350 --> 00:36:15,160
So the new top of the
resulting fraction.

725
00:36:15,160 --> 00:36:20,110
So it's my numerator multiplied
by the other denominator

726
00:36:20,110 --> 00:36:24,010
plus my denominator multiplied
by the other numerator

727
00:36:24,010 --> 00:36:26,410
and then divided by the
multiplication of the two

728
00:36:26,410 --> 00:36:28,810
denominators.

729
00:36:28,810 --> 00:36:32,250
So the top is going to be that,
the bottom is going to be that.

730
00:36:32,250 --> 00:36:34,950
Notice that we're
using self dot, right?

731
00:36:34,950 --> 00:36:36,480
Once again, we're
trying to access

732
00:36:36,480 --> 00:36:39,430
the data attributes of
each different instance,

733
00:36:39,430 --> 00:36:42,760
right, of myself and the other
object that I'm working with.

734
00:36:42,760 --> 00:36:46,660
So that's why I have
to use self dot here.

735
00:36:46,660 --> 00:36:51,450
Once I figure out the top and
the bottom of the addition,

736
00:36:51,450 --> 00:36:55,130
I'm going to return,
and here notice I'm

737
00:36:55,130 --> 00:36:58,190
returning a fraction object.

738
00:36:58,190 --> 00:37:00,680
It's not a number, it's not
a float, it's not an integer.

739
00:37:00,680 --> 00:37:03,890
It's a new object that is of
the exact same type as the class

740
00:37:03,890 --> 00:37:07,140
that I'm implementing.

741
00:37:07,140 --> 00:37:10,410
So as it's the same
type of object,

742
00:37:10,410 --> 00:37:12,304
then on the return
value I can do

743
00:37:12,304 --> 00:37:14,220
all of the exact same
operations that I can do

744
00:37:14,220 --> 00:37:17,960
on a regular fraction object.

745
00:37:17,960 --> 00:37:19,587
Sub is going to be the same.

746
00:37:19,587 --> 00:37:20,920
I'm returning a fraction object.

747
00:37:24,250 --> 00:37:30,330
Float is just going to
do the division for me,

748
00:37:30,330 --> 00:37:31,860
so it's going to
take the numerator

749
00:37:31,860 --> 00:37:34,350
and then divide it
by the denominator,

750
00:37:34,350 --> 00:37:37,130
just divide the numbers.

751
00:37:37,130 --> 00:37:42,790
And then I'm defining here
my own method called inverse.

752
00:37:42,790 --> 00:37:45,580
And this is just going to take
the inverse of the instance I'm

753
00:37:45,580 --> 00:37:47,260
calling this method on.

754
00:37:47,260 --> 00:37:51,820
And so it's going to also return
a new fraction object that just

755
00:37:51,820 --> 00:37:53,830
has the denominator
as the top part

756
00:37:53,830 --> 00:37:55,531
and the numerator
as the bottom part.

757
00:37:58,900 --> 00:38:00,280
So then we have some code here.

758
00:38:00,280 --> 00:38:04,970
So that's how I implement
my fraction object.

759
00:38:04,970 --> 00:38:08,040
So now let's use it and
see what it gives us.

760
00:38:08,040 --> 00:38:09,290
A is equal to a fraction 1, 4.

761
00:38:20,940 --> 00:38:28,870
This is going to
be 1 over 4 for a.

762
00:38:28,870 --> 00:38:31,600
And b is going to
be 3 over four.

763
00:38:35,240 --> 00:38:41,400
When I do C, notice I'm using
the plus operator between two

764
00:38:41,400 --> 00:38:42,930
fraction objects, right?

765
00:38:42,930 --> 00:38:45,180
A and b are fraction
objects so Python's

766
00:38:45,180 --> 00:38:48,759
going to say, OK, is there an
underscore, underscore, add,

767
00:38:48,759 --> 00:38:50,550
underscore, underscore,
method implemented?

768
00:38:50,550 --> 00:38:54,730
It is and it's just going to
do whatever's inside here.

769
00:38:54,730 --> 00:38:56,980
So it's going to say self
dot numerator plus other dot

770
00:38:56,980 --> 00:38:57,962
denominator.

771
00:38:57,962 --> 00:38:59,920
It's going to calculate
the top and the bottom.

772
00:38:59,920 --> 00:39:01,656
It's going to turn a
new fraction object.

773
00:39:05,470 --> 00:39:27,100
So this is going to be 4 plus 12
divided by 16, and 16 over 16.

774
00:39:27,100 --> 00:39:29,800
So C as a fraction
object is going

775
00:39:29,800 --> 00:39:35,260
to be 16 for the numerator
and 16 for the denominator

776
00:39:35,260 --> 00:39:38,058
because it's a fraction object.

777
00:39:43,890 --> 00:39:46,290
If I print C, it should
print 16 over 16,

778
00:39:46,290 --> 00:39:50,760
so we can even run it,
so print 16 over 16.

779
00:39:50,760 --> 00:39:54,570
If I print floats C, so this
special method float here

780
00:39:54,570 --> 00:39:58,920
is going to say, is there a
method that converts a fraction

781
00:39:58,920 --> 00:40:00,090
to a float and there is.

782
00:40:00,090 --> 00:40:02,229
It's this one
implemented right here.

783
00:40:02,229 --> 00:40:04,770
So it's just going to divide
the two numbers, top and bottom,

784
00:40:04,770 --> 00:40:07,020
which gives me 1.

785
00:40:07,020 --> 00:40:10,720
So it's this one here and here.

786
00:40:10,720 --> 00:40:13,380
Notice I'm doing the
exact same method call,

787
00:40:13,380 --> 00:40:15,270
except I'm doing it
the other way where

788
00:40:15,270 --> 00:40:20,610
you type in the name of the
class, name of the method,

789
00:40:20,610 --> 00:40:22,350
and then what you're
calling it on,

790
00:40:22,350 --> 00:40:27,430
and this gives the exact
same value here, 1.0.

791
00:40:27,430 --> 00:40:30,640
And then here I'm calling
the method inverse

792
00:40:30,640 --> 00:40:36,850
on object B which is going to
invert 3 over 4 to be 4 over 3.

793
00:40:36,850 --> 00:40:39,040
And then I'm converting
it to a float

794
00:40:39,040 --> 00:40:40,420
and then I'm printing the value.

795
00:40:40,420 --> 00:40:43,350
So it gives me 1.33.

796
00:40:43,350 --> 00:40:50,820
So take a look at this
code in more detail

797
00:40:50,820 --> 00:40:54,060
and see if you can trace through
all of those different things

798
00:40:54,060 --> 00:40:57,560
and see if you can also write
your own new fraction objects.

799
00:40:57,560 --> 00:40:58,260
OK.

800
00:40:58,260 --> 00:41:00,360
So last slide.

801
00:41:00,360 --> 00:41:02,730
Power of object
oriented programming

802
00:41:02,730 --> 00:41:04,740
is that you can bundle
together objects that

803
00:41:04,740 --> 00:41:06,240
are of the exact same type.

804
00:41:06,240 --> 00:41:07,680
And all of these
objects are going

805
00:41:07,680 --> 00:41:09,720
to have the same
data representation

806
00:41:09,720 --> 00:41:13,030
and the same methods
that you can do on them.

807
00:41:13,030 --> 00:41:15,730
And ultimately, you're
going to be building

808
00:41:15,730 --> 00:41:17,240
these layers of abstraction.

809
00:41:17,240 --> 00:41:20,170
So you're going to be building
on a basic object type

810
00:41:20,170 --> 00:41:27,160
in Python, you're going to have
integer objects, float objects.

811
00:41:27,160 --> 00:41:30,106
On top of those, you can
create lists, dictionaries.

812
00:41:30,106 --> 00:41:31,480
And on top of
those, you can even

813
00:41:31,480 --> 00:41:37,080
create your own object types as
we saw in this lecture today.