1
00:00:00,790 --> 00:00:03,190
The following content is
provided under a Creative

2
00:00:03,190 --> 00:00:04,730
Commons license.

3
00:00:04,730 --> 00:00:07,030
Your support will help
MIT OpenCourseWare

4
00:00:07,030 --> 00:00:11,390
continue to offer high-quality,
educational resources for free.

5
00:00:11,390 --> 00:00:13,990
To make a donation, or
view additional materials

6
00:00:13,990 --> 00:00:17,880
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:17,880 --> 00:00:18,850
at ocw.mit.edu.

8
00:00:29,957 --> 00:00:30,790
ANA BELL: All right.

9
00:00:30,790 --> 00:00:33,100
Let's begin.

10
00:00:33,100 --> 00:00:35,830
As I mentioned
before, this lecture

11
00:00:35,830 --> 00:00:37,690
will be recorded for OCW.

12
00:00:37,690 --> 00:00:39,309
Again, in future
lectures, if you

13
00:00:39,309 --> 00:00:41,350
don't want to have the
back of your head show up,

14
00:00:41,350 --> 00:00:44,880
just don't sit in
this front area here.

15
00:00:44,880 --> 00:00:46,630
First of all, wow,
what a crowd, you guys.

16
00:00:46,630 --> 00:00:48,490
We're finally in 26-100.

17
00:00:48,490 --> 00:00:52,240
6.0001 made it big, huh?

18
00:00:52,240 --> 00:00:55,960
Good afternoon and welcome to
the very first class of 6.0001,

19
00:00:55,960 --> 00:00:58,960
and also 600, this semester.

20
00:00:58,960 --> 00:01:00,610
My name is Ana Bell.

21
00:01:00,610 --> 00:01:01,840
First name, Ana.

22
00:01:01,840 --> 00:01:03,250
Last name, Bell.

23
00:01:03,250 --> 00:01:06,460
I'm a lecturer in
the EECS Department.

24
00:01:06,460 --> 00:01:08,680
And I'll be giving some
of the lectures for today,

25
00:01:08,680 --> 00:01:13,030
along with later on in the term,
Professor Eric Grimson, who's

26
00:01:13,030 --> 00:01:15,820
sitting right down there, will
be giving some of the lectures,

27
00:01:15,820 --> 00:01:17,620
as well.

28
00:01:17,620 --> 00:01:21,550
Today we're going to go over
some basic administrivia,

29
00:01:21,550 --> 00:01:23,101
a little bit of
course information.

30
00:01:23,101 --> 00:01:24,850
And then, we're going
to talk a little bit

31
00:01:24,850 --> 00:01:26,164
about what is computation?

32
00:01:26,164 --> 00:01:27,580
We'll discuss at
a very high level

33
00:01:27,580 --> 00:01:29,860
what computers do just
to make sure we're all

34
00:01:29,860 --> 00:01:31,610
on the same page.

35
00:01:31,610 --> 00:01:34,180
And then, we're going to dive
right into Python basics.

36
00:01:34,180 --> 00:01:36,763
We're going to talk a little bit
about mathematical operations

37
00:01:36,763 --> 00:01:38,134
you can do with Python.

38
00:01:38,134 --> 00:01:40,300
And then, we're going to
talk about Python variables

39
00:01:40,300 --> 00:01:42,010
and types.

40
00:01:42,010 --> 00:01:43,907
As I mentioned in my
introductory email, all

41
00:01:43,907 --> 00:01:46,240
the slides and code that I'll
talk about during lectures

42
00:01:46,240 --> 00:01:48,250
will be up before
lecture, so I highly

43
00:01:48,250 --> 00:01:52,540
encourage you to download
them and to have them open.

44
00:01:52,540 --> 00:01:56,020
We're going to go through some
in-class exercises which will

45
00:01:56,020 --> 00:01:57,820
be available on those slides.

46
00:01:57,820 --> 00:01:59,830
And it's fun to do.

47
00:01:59,830 --> 00:02:07,420
And it's also great if could
take notes about the code just

48
00:02:07,420 --> 00:02:09,210
for future reference.

49
00:02:09,210 --> 00:02:10,210
It's true.

50
00:02:10,210 --> 00:02:12,220
This is a really
fast-paced course,

51
00:02:12,220 --> 00:02:14,110
and we ramp up really quickly.

52
00:02:14,110 --> 00:02:17,842
We do want to position you
to succeed in this course.

53
00:02:17,842 --> 00:02:19,300
As I was writing
this, I was trying

54
00:02:19,300 --> 00:02:21,160
to think about when
I was first starting

55
00:02:21,160 --> 00:02:24,580
to program what helped
me get through my very

56
00:02:24,580 --> 00:02:26,110
first programming course.

57
00:02:26,110 --> 00:02:29,470
And this is really a good list.

58
00:02:29,470 --> 00:02:31,840
The first thing was I just
read the psets as soon

59
00:02:31,840 --> 00:02:37,600
as they came out, made sure that
the terminology just sunk in.

60
00:02:37,600 --> 00:02:39,760
And then, during
lectures, if the lecturer

61
00:02:39,760 --> 00:02:42,967
was talking about something
that suddenly I remembered,

62
00:02:42,967 --> 00:02:45,550
oh, I saw that word in the pset
and I didn't know what it was.

63
00:02:45,550 --> 00:02:46,720
Well, hey, now I
know what it is.

64
00:02:46,720 --> 00:02:47,200
Right?

65
00:02:47,200 --> 00:02:48,158
So just give it a read.

66
00:02:48,158 --> 00:02:51,520
You don't need to start it.

67
00:02:51,520 --> 00:02:55,390
If you're new to programming, I
think the key word is practice.

68
00:02:55,390 --> 00:02:57,880
It's like math or reading.

69
00:02:57,880 --> 00:03:00,260
The more you practice,
the better you get at it.

70
00:03:00,260 --> 00:03:01,877
You're not going to
absorb programming

71
00:03:01,877 --> 00:03:04,210
by watching me write programs
because I already know how

72
00:03:04,210 --> 00:03:05,170
to program.

73
00:03:05,170 --> 00:03:07,966
You guys need to practice.

74
00:03:07,966 --> 00:03:09,340
Download the code
before lecture.

75
00:03:09,340 --> 00:03:10,090
Follow along.

76
00:03:10,090 --> 00:03:12,430
Whatever I type,
you guys can type.

77
00:03:12,430 --> 00:03:14,436
And I think, also,
one of the big things

78
00:03:14,436 --> 00:03:16,060
is if you're new to
programming, you're

79
00:03:16,060 --> 00:03:19,360
kind of afraid that you're
going to break your computer.

80
00:03:19,360 --> 00:03:24,400
And you can't really do that
just by running Anaconda

81
00:03:24,400 --> 00:03:26,485
and typing in some commands.

82
00:03:26,485 --> 00:03:28,360
So don't be afraid to
just type some stuff in

83
00:03:28,360 --> 00:03:29,480
and see what it does.

84
00:03:29,480 --> 00:03:31,230
Worst case, you just
restart the computer.

85
00:03:35,390 --> 00:03:36,411
Yeah.

86
00:03:36,411 --> 00:03:38,160
That's probably the
big thing right there.

87
00:03:38,160 --> 00:03:39,743
I should have probably
highlighted it,

88
00:03:39,743 --> 00:03:40,881
but don't be afraid.

89
00:03:40,881 --> 00:03:41,380
Great.

90
00:03:41,380 --> 00:03:46,780
So this is pretty much a
roadmap of all of 6.0001 or 600

91
00:03:46,780 --> 00:03:47,890
as I've just explained it.

92
00:03:47,890 --> 00:03:51,880
There's three big things we
want to get out of this course.

93
00:03:51,880 --> 00:03:54,130
The first thing is the
knowledge of concepts,

94
00:03:54,130 --> 00:03:56,650
which is pretty much true of
any class that you'll take.

95
00:03:56,650 --> 00:03:59,740
The class will teach you
something through lectures.

96
00:03:59,740 --> 00:04:02,500
Exams will test
how much you know.

97
00:04:02,500 --> 00:04:05,830
This is a class in programming.

98
00:04:05,830 --> 00:04:08,950
The other thing we want
you to get out of it

99
00:04:08,950 --> 00:04:10,841
is programming skills.

100
00:04:10,841 --> 00:04:12,340
And the last thing,
and I think this

101
00:04:12,340 --> 00:04:13,923
is what makes this
class really great,

102
00:04:13,923 --> 00:04:16,240
is we teach you how
to solve problems.

103
00:04:16,240 --> 00:04:18,730
And we do that
through the psets.

104
00:04:18,730 --> 00:04:21,010
That's really how I feel
the roadmap of this course

105
00:04:21,010 --> 00:04:22,600
looks like.

106
00:04:22,600 --> 00:04:25,300
And underlying all of
these is just practice.

107
00:04:25,300 --> 00:04:29,800
You have to just type some
stuff away and code a lot.

108
00:04:29,800 --> 00:04:33,490
And you'll succeed in
this course, I think.

109
00:04:33,490 --> 00:04:35,590
OK.

110
00:04:35,590 --> 00:04:38,800
So what are the things we're
going to learn in this class?

111
00:04:38,800 --> 00:04:41,650
I feel like the things we're
going learn in this class

112
00:04:41,650 --> 00:04:44,470
can be divided into basically
three different sections.

113
00:04:44,470 --> 00:04:50,290
The first one is related to
these first two items here.

114
00:04:50,290 --> 00:04:53,380
It's really about
learning how to program.

115
00:04:53,380 --> 00:04:55,330
Learning how to
program, part of it

116
00:04:55,330 --> 00:04:58,990
is figuring out what
objects to create.

117
00:04:58,990 --> 00:05:00,394
You'll learn about these later.

118
00:05:00,394 --> 00:05:02,560
How do you represent knowledge
with data structures?

119
00:05:02,560 --> 00:05:04,529
That's sort of the
broad term for that.

120
00:05:04,529 --> 00:05:06,070
And then, as you're
writing programs,

121
00:05:06,070 --> 00:05:08,830
you need to-- programs
aren't just linear.

122
00:05:08,830 --> 00:05:10,300
Sometimes programs jump around.

123
00:05:10,300 --> 00:05:11,260
They make decisions.

124
00:05:11,260 --> 00:05:13,690
There's some control
flow to programs.

125
00:05:13,690 --> 00:05:18,620
That's what the second
line is going to be about.

126
00:05:18,620 --> 00:05:20,900
The second big
part of this course

127
00:05:20,900 --> 00:05:24,590
is a little bit more
abstract, and it

128
00:05:24,590 --> 00:05:29,000
deals with how do you write
good code, good style,

129
00:05:29,000 --> 00:05:30,530
code that's readable.

130
00:05:30,530 --> 00:05:33,020
When you write code, you
want to write it such

131
00:05:33,020 --> 00:05:35,480
that-- you're in big company,
other people will read it,

132
00:05:35,480 --> 00:05:37,970
other people will
use it, so it has

133
00:05:37,970 --> 00:05:40,220
to be readable and
understandable by others.

134
00:05:40,220 --> 00:05:41,900
To that end, you
need to write code

135
00:05:41,900 --> 00:05:48,820
that's well organized,
modular, easy to understand.

136
00:05:48,820 --> 00:05:50,570
And not only that, not
only will your code

137
00:05:50,570 --> 00:05:53,577
be read by other people,
but next year, maybe,

138
00:05:53,577 --> 00:05:55,160
you'll take another
course, and you'll

139
00:05:55,160 --> 00:05:56,868
want to look back at
some of the problems

140
00:05:56,868 --> 00:05:58,320
that you wrote in this class.

141
00:05:58,320 --> 00:06:00,740
You want to be able
to reread your code.

142
00:06:00,740 --> 00:06:03,950
If it's a big mess, you might
not be able to understand--

143
00:06:03,950 --> 00:06:06,530
or reunderstand--
what you were doing.

144
00:06:06,530 --> 00:06:08,630
So writing readable
code and organizing code

145
00:06:08,630 --> 00:06:10,360
is also a big part.

146
00:06:10,360 --> 00:06:15,680
And the last section is going
to deal with-- the first two

147
00:06:15,680 --> 00:06:19,100
are actually part of the
programming in Introduction

148
00:06:19,100 --> 00:06:21,440
to Programming and
Computer Science in Python.

149
00:06:21,440 --> 00:06:26,000
And the last one deals mostly
with the computer science part

150
00:06:26,000 --> 00:06:29,540
in Introduction to Programming
and Computer Science in Python.

151
00:06:29,540 --> 00:06:31,970
We're going to talk about,
once you have learned

152
00:06:31,970 --> 00:06:33,650
how to write programs
in Python, how do

153
00:06:33,650 --> 00:06:35,540
you compare programs in Python?

154
00:06:35,540 --> 00:06:38,162
How do you know that one program
is better than the other?

155
00:06:38,162 --> 00:06:39,620
How do you know
that one program is

156
00:06:39,620 --> 00:06:41,084
more efficient than the other?

157
00:06:41,084 --> 00:06:42,500
How do you know
that one algorithm

158
00:06:42,500 --> 00:06:45,230
is better than the other?

159
00:06:45,230 --> 00:06:47,480
That's what we're going to
talk about in the last part

160
00:06:47,480 --> 00:06:48,850
of the course.

161
00:06:48,850 --> 00:06:50,250
OK.

162
00:06:50,250 --> 00:06:52,920
That's all for the
administrative part

163
00:06:52,920 --> 00:06:54,230
of the course.

164
00:06:54,230 --> 00:06:59,640
Let's start by talking at a high
level what does a computer do.

165
00:06:59,640 --> 00:07:03,130
Fundamentally, it
does two things.

166
00:07:03,130 --> 00:07:05,960
One, performs calculations.

167
00:07:05,960 --> 00:07:07,770
It performs a lot
of calculations.

168
00:07:07,770 --> 00:07:09,680
Computers these days
are really, really fast,

169
00:07:09,680 --> 00:07:15,240
a billion calculations per
second is probably not far off.

170
00:07:15,240 --> 00:07:16,920
It performs these
calculations and it

171
00:07:16,920 --> 00:07:18,550
has to store them somewhere.

172
00:07:18,550 --> 00:07:19,050
Right?

173
00:07:19,050 --> 00:07:21,030
Stores them in computer memory.

174
00:07:21,030 --> 00:07:24,070
So a computer also has
to remember results.

175
00:07:24,070 --> 00:07:26,280
And these days, it's not
uncommon to find computers

176
00:07:26,280 --> 00:07:30,390
with hundreds of
gigabytes of storage.

177
00:07:30,390 --> 00:07:34,457
The kinds of calculations
that computers do,

178
00:07:34,457 --> 00:07:35,290
there are two kinds.

179
00:07:35,290 --> 00:07:37,590
One are calculations that
are built into the language.

180
00:07:37,590 --> 00:07:39,450
These are the very
low level types

181
00:07:39,450 --> 00:07:41,890
of calculations,
things like addition,

182
00:07:41,890 --> 00:07:45,610
subtraction,
multiplication, and so on.

183
00:07:45,610 --> 00:07:47,790
And once you have
a language that

184
00:07:47,790 --> 00:07:53,070
has these primitive calculation
types, you, as a programmer,

185
00:07:53,070 --> 00:07:55,890
can put these types
together and then define

186
00:07:55,890 --> 00:07:57,680
your own calculations.

187
00:07:57,680 --> 00:08:00,210
You can create new
types of calculations.

188
00:08:00,210 --> 00:08:04,570
And the computer will be able
to perform those, as well.

189
00:08:04,570 --> 00:08:07,810
I think, one thing
I want to stress--

190
00:08:07,810 --> 00:08:09,930
and we're going to
come back to this

191
00:08:09,930 --> 00:08:12,300
again during this entire
lecture, actually--

192
00:08:12,300 --> 00:08:15,690
is computers only know
what you tell them.

193
00:08:15,690 --> 00:08:18,220
Computers only do what
you tell them to do.

194
00:08:18,220 --> 00:08:19,860
They're not magical.

195
00:08:19,860 --> 00:08:22,667
They don't have a mind.

196
00:08:22,667 --> 00:08:24,750
They just know how to
perform calculations really,

197
00:08:24,750 --> 00:08:26,340
really quickly.

198
00:08:26,340 --> 00:08:29,936
But you have to tell them
what calculations to do.

199
00:08:32,940 --> 00:08:34,500
Computers don't know anything.

200
00:08:34,500 --> 00:08:35,220
All right.

201
00:08:35,220 --> 00:08:36,050
We've come to that.

202
00:08:40,059 --> 00:08:44,320
Let's go into the
types of knowledge.

203
00:08:44,320 --> 00:08:48,220
The first type of knowledge
is declarative knowledge.

204
00:08:48,220 --> 00:08:50,730
And those are things
like statements of fact.

205
00:08:50,730 --> 00:08:53,080
And this is where my
email came into play.

206
00:08:53,080 --> 00:08:55,500
If you read it all
the way to the bottom,

207
00:08:55,500 --> 00:08:57,960
you would have entered a raffle.

208
00:08:57,960 --> 00:08:59,890
So a statement of fact
for today's lecture

209
00:08:59,890 --> 00:09:03,280
is, someone will win a
prize before class ends.

210
00:09:03,280 --> 00:09:06,820
And the prize was
a Google Cardboard.

211
00:09:06,820 --> 00:09:09,890
Google state-of-the-art
virtual reality glasses.

212
00:09:09,890 --> 00:09:11,474
And I have them right here.

213
00:09:14,400 --> 00:09:15,950
Yea.

214
00:09:15,950 --> 00:09:18,650
I delivered on my promise.

215
00:09:18,650 --> 00:09:20,770
That's a statement of fact.

216
00:09:20,770 --> 00:09:22,600
So pretend I'm a machine.

217
00:09:22,600 --> 00:09:23,480
OK?

218
00:09:23,480 --> 00:09:26,990
I don't know anything
except what you tell me.

219
00:09:26,990 --> 00:09:28,100
I don't know.

220
00:09:28,100 --> 00:09:30,320
I know that you tell
me this statement.

221
00:09:30,320 --> 00:09:31,847
I'm like, OK.

222
00:09:31,847 --> 00:09:33,930
But how is someone going
to win a Google Cardboard

223
00:09:33,930 --> 00:09:35,459
before class ends, right?

224
00:09:35,459 --> 00:09:37,250
That's where imperative
knowledge comes in.

225
00:09:37,250 --> 00:09:39,530
Imperative knowledge is
the recipe, or the how-to,

226
00:09:39,530 --> 00:09:42,230
or the sequence of steps.

227
00:09:42,230 --> 00:09:43,780
Sorry.

228
00:09:43,780 --> 00:09:47,210
That's just my
funny for that one.

229
00:09:47,210 --> 00:09:53,530
So the sequence of steps
is imperative knowledge.

230
00:09:53,530 --> 00:09:57,930
If I'm a machine,
you need to tell me

231
00:09:57,930 --> 00:10:00,910
how someone will win a Google
Cardboard before class.

232
00:10:00,910 --> 00:10:02,680
If I follow these
steps, then technically,

233
00:10:02,680 --> 00:10:06,460
I should reach a conclusion.

234
00:10:06,460 --> 00:10:08,950
Step one, I think we've
already done that.

235
00:10:08,950 --> 00:10:11,590
Whoever wanted to
sign up has signed up.

236
00:10:11,590 --> 00:10:13,180
Now I'm going to open my IDE.

237
00:10:13,180 --> 00:10:14,680
I'm just basically
being a machine

238
00:10:14,680 --> 00:10:17,740
and following the steps
that you've told me.

239
00:10:17,740 --> 00:10:21,631
The IDE that we're using in
this class is called Anaconda.

240
00:10:21,631 --> 00:10:25,330
I'm just scrolling
down to the bottom.

241
00:10:25,330 --> 00:10:28,660
Hopefully, you've installed
it in problem set zero.

242
00:10:28,660 --> 00:10:30,610
I've opened my IDE.

243
00:10:30,610 --> 00:10:34,012
I'm going to follow the
next set of instructions.

244
00:10:34,012 --> 00:10:36,220
I'm going to choose a random
number between the first

245
00:10:36,220 --> 00:10:39,460
and the nth responder.

246
00:10:39,460 --> 00:10:42,340
Now, I'm going to actually
use Python to do this .

247
00:10:42,340 --> 00:10:44,620
And this is also an
example of how just

248
00:10:44,620 --> 00:10:46,310
a really simple
task in your life,

249
00:10:46,310 --> 00:10:48,742
you can use computers or
programming to do that.

250
00:10:48,742 --> 00:10:50,200
Because if I chose
a random number,

251
00:10:50,200 --> 00:10:51,824
I might be biased
because, for example,

252
00:10:51,824 --> 00:10:53,860
I might like the number 8.

253
00:10:53,860 --> 00:10:57,399
To choose a random number,
I'm going to go and say, OK,

254
00:10:57,399 --> 00:10:58,690
where's the list of responders?

255
00:10:58,690 --> 00:10:59,800
It starts at 15.

256
00:10:59,800 --> 00:11:03,070
Actually, it starts at
16 because that's me.

257
00:11:03,070 --> 00:11:05,440
We're going to choose a
random number between 16

258
00:11:05,440 --> 00:11:09,210
and the end person 266.

259
00:11:09,210 --> 00:11:11,190
Oh, we just got-- oh.

260
00:11:11,190 --> 00:11:13,070
OK.

261
00:11:13,070 --> 00:11:13,570
OK.

262
00:11:13,570 --> 00:11:15,028
I'm going to cut
it off right here.

263
00:11:15,028 --> 00:11:15,541
271.

264
00:11:15,541 --> 00:11:16,040
OK.

265
00:11:16,040 --> 00:11:18,490
16 and 271.

266
00:11:18,490 --> 00:11:19,330
Perfect.

267
00:11:19,330 --> 00:11:20,380
OK.

268
00:11:20,380 --> 00:11:21,880
I'm going to choose
a random number.

269
00:11:21,880 --> 00:11:22,900
I'm going to go to my IDE.

270
00:11:22,900 --> 00:11:24,490
And you don't need to
know how to do this yet,

271
00:11:24,490 --> 00:11:26,115
but by the end of
this class, you will.

272
00:11:26,115 --> 00:11:29,191
I'm just going to use Python.

273
00:11:29,191 --> 00:11:31,690
I'm just going to get the random
number package that's going

274
00:11:31,690 --> 00:11:32,950
to give me a random number.

275
00:11:32,950 --> 00:11:35,820
I'm going to say random.randint.

276
00:11:35,820 --> 00:11:40,510
And I'm going to choose a random
number between 16 and 272,

277
00:11:40,510 --> 00:11:41,380
OK.

278
00:11:41,380 --> 00:11:42,440
75.

279
00:11:42,440 --> 00:11:43,690
OK.

280
00:11:43,690 --> 00:11:44,800
Great.

281
00:11:44,800 --> 00:11:45,880
I chose a random number.

282
00:11:45,880 --> 00:11:48,557
And I'm going to find the
number in the responder's sheet.

283
00:11:48,557 --> 00:11:49,640
What was the number again?

284
00:11:49,640 --> 00:11:51,040
Sorry.

285
00:11:51,040 --> 00:11:52,000
75.

286
00:11:52,000 --> 00:11:54,020
OK.

287
00:11:54,020 --> 00:11:56,080
Up we go.

288
00:11:56,080 --> 00:11:57,710
There we go.

289
00:11:57,710 --> 00:12:01,300
Lauren Z-O-V. Yeah.

290
00:12:01,300 --> 00:12:02,060
Nice.

291
00:12:02,060 --> 00:12:02,710
You're here.

292
00:12:14,180 --> 00:12:16,110
Awesome.

293
00:12:16,110 --> 00:12:17,810
All right.

294
00:12:17,810 --> 00:12:21,200
That's an example of me
being a machine and also,

295
00:12:21,200 --> 00:12:23,870
at the same time, using
Python in my everyday life,

296
00:12:23,870 --> 00:12:28,650
just lecturing, to
find a random number.

297
00:12:28,650 --> 00:12:30,350
Try to use Python
wherever you can.

298
00:12:30,350 --> 00:12:31,725
And that just
gives you practice.

299
00:12:34,580 --> 00:12:35,770
That was fun.

300
00:12:35,770 --> 00:12:37,190
But we're at MIT.

301
00:12:37,190 --> 00:12:39,110
We're MIT students.

302
00:12:39,110 --> 00:12:41,900
And we love numbers here at MIT.

303
00:12:41,900 --> 00:12:44,749
Here's a numerical
example that shows

304
00:12:44,749 --> 00:12:46,790
the difference between
declarative and imperative

305
00:12:46,790 --> 00:12:50,000
knowledge.

306
00:12:50,000 --> 00:12:51,470
An example of
declarative knowledge

307
00:12:51,470 --> 00:12:54,530
is the square root of a number
x is y such that y times y

308
00:12:54,530 --> 00:12:57,020
is equal to x.

309
00:12:57,020 --> 00:12:59,010
That's just a statement
of fact It's true.

310
00:13:02,300 --> 00:13:05,872
Computers don't know
what to do with that.

311
00:13:05,872 --> 00:13:07,830
They don't know what to
do with that statement.

312
00:13:07,830 --> 00:13:11,270
But computers do know
how to follow a recipe.

313
00:13:11,270 --> 00:13:13,250
Here's a well-known algorithm.

314
00:13:13,250 --> 00:13:16,550
To find the square
root of a number x,

315
00:13:16,550 --> 00:13:23,070
let's say x is originally
16, if a computer follows

316
00:13:23,070 --> 00:13:26,640
this algorithm, it's going
to start with a guess, g,

317
00:13:26,640 --> 00:13:28,620
let's say, 3.

318
00:13:28,620 --> 00:13:30,940
We're trying to find
the square root of 16.

319
00:13:30,940 --> 00:13:34,320
We're going to calculate
g times g is 9.

320
00:13:34,320 --> 00:13:36,120
And we're going to
ask is if g times g

321
00:13:36,120 --> 00:13:39,670
is close enough to x, then
stop and say, g is the answer.

322
00:13:39,670 --> 00:13:42,699
I'm not really happy with
9 being really close to 16.

323
00:13:42,699 --> 00:13:44,490
So I'm going to say,
I'm not stopping here.

324
00:13:44,490 --> 00:13:47,130
I'm going to keep going.

325
00:13:47,130 --> 00:13:48,690
If it's not close
enough, then I'm

326
00:13:48,690 --> 00:13:52,920
going to make a new guess
by averaging g and x over g.

327
00:13:52,920 --> 00:13:54,480
That's x over g here.

328
00:13:54,480 --> 00:13:57,150
And that's the
average over there.

329
00:13:57,150 --> 00:14:00,120
And the new average is
going to be my new guess.

330
00:14:04,320 --> 00:14:05,430
And that's what it says.

331
00:14:05,430 --> 00:14:07,680
And then, the last step
is using the new guess,

332
00:14:07,680 --> 00:14:08,790
repeat the process.

333
00:14:08,790 --> 00:14:11,610
Then we go back to the beginning
and repeat the whole process

334
00:14:11,610 --> 00:14:13,484
over and over again.

335
00:14:13,484 --> 00:14:15,150
And that's what the
rest of the rows do.

336
00:14:15,150 --> 00:14:16,590
And you keep doing
this until you decide

337
00:14:16,590 --> 00:14:17,631
that you're close enough.

338
00:14:23,340 --> 00:14:25,140
What we saw for the
imperative knowledge

339
00:14:25,140 --> 00:14:26,610
in the previous
numerical example

340
00:14:26,610 --> 00:14:31,604
was the recipe for how to
find the square root of x.

341
00:14:31,604 --> 00:14:33,270
What were the three
parts of the recipe?

342
00:14:33,270 --> 00:14:36,090
One was a simple
sequence of steps.

343
00:14:36,090 --> 00:14:39,270
There were four steps.

344
00:14:39,270 --> 00:14:42,660
The other was a flow of
control, so there were

345
00:14:42,660 --> 00:14:45,360
parts where we made decisions.

346
00:14:45,360 --> 00:14:46,980
Are we close enough?

347
00:14:46,980 --> 00:14:49,320
There were parts where
we repeated some steps.

348
00:14:49,320 --> 00:14:52,890
At the end, we said,
repeat steps 1, 2, 3.

349
00:14:52,890 --> 00:14:55,320
That's the flow of control.

350
00:14:55,320 --> 00:14:58,340
And the last part of the
recipe was a way to stop.

351
00:14:58,340 --> 00:15:00,660
You don't want a program
that keeps going and going.

352
00:15:00,660 --> 00:15:03,869
Or for a recipe, you don't want
to keep baking bread forever.

353
00:15:03,869 --> 00:15:05,160
You want to stop at some point.

354
00:15:05,160 --> 00:15:07,800
Like 10 breads is enough, right?

355
00:15:07,800 --> 00:15:10,230
So you have to have
a way of stopping.

356
00:15:10,230 --> 00:15:12,780
In the previous example,
the way of stopping

357
00:15:12,780 --> 00:15:15,240
was that we decided
we were close enough.

358
00:15:15,240 --> 00:15:20,261
Close enough was maybe
being within .01, .001,

359
00:15:20,261 --> 00:15:21,010
whatever you pick.

360
00:15:23,830 --> 00:15:26,550
This recipe is there
for an algorithm.

361
00:15:26,550 --> 00:15:29,248
In computer science speak,
it's going to be an algorithm.

362
00:15:29,248 --> 00:15:31,622
And that's what we're going
to learn about in this class.

363
00:15:34,532 --> 00:15:35,740
We're dealing with computers.

364
00:15:35,740 --> 00:15:37,990
And we actually want
to capture a recipe

365
00:15:37,990 --> 00:15:41,095
inside a computer, a computer
being a mechanical process.

366
00:15:49,640 --> 00:15:52,952
Historically, there were two
different types of computers.

367
00:15:55,540 --> 00:15:57,730
Originally, there
were these things

368
00:15:57,730 --> 00:15:59,800
called fixed-program computers.

369
00:15:59,800 --> 00:16:02,110
And I'm old enough to
have used something

370
00:16:02,110 --> 00:16:06,710
like this, where there's
just numbers and plus, minus,

371
00:16:06,710 --> 00:16:08,920
multiplication,
divide, and equal.

372
00:16:08,920 --> 00:16:11,350
But calculators these days
are a lot more complicated.

373
00:16:11,350 --> 00:16:15,280
But way back then, an example
of a fixed-program computer

374
00:16:15,280 --> 00:16:16,210
is this calculator.

375
00:16:16,210 --> 00:16:19,190
It only knows how to do
addition, multiplication,

376
00:16:19,190 --> 00:16:20,740
subtraction, division.

377
00:16:20,740 --> 00:16:22,480
If you want to plot
something, you can't.

378
00:16:22,480 --> 00:16:27,040
If you want to go on the
internet, send email with it,

379
00:16:27,040 --> 00:16:27,780
you can't.

380
00:16:27,780 --> 00:16:31,040
It can only do this one thing.

381
00:16:31,040 --> 00:16:33,610
And if you wanted to create a
machine that did another thing,

382
00:16:33,610 --> 00:16:37,360
then you'd have to create
another fixed-program computer

383
00:16:37,360 --> 00:16:39,970
that did a completely
separate test.

384
00:16:39,970 --> 00:16:41,890
That's not very great.

385
00:16:41,890 --> 00:16:45,910
That's when stored-program
computers came into play.

386
00:16:45,910 --> 00:16:47,710
And these were machines
that could store

387
00:16:47,710 --> 00:16:50,530
a sequence of instructions.

388
00:16:50,530 --> 00:16:54,729
And these machines could execute
the sequence of instructions.

389
00:16:54,729 --> 00:16:56,770
And you could change the
sequence of instructions

390
00:16:56,770 --> 00:17:00,220
and execute this different
sequence of instructions.

391
00:17:00,220 --> 00:17:03,490
You could do different
tasks in the same machine.

392
00:17:03,490 --> 00:17:07,930
And that's the computer
as we know it these days.

393
00:17:07,930 --> 00:17:11,119
The central processing unit is
where all of these decisions

394
00:17:11,119 --> 00:17:11,619
get made.

395
00:17:11,619 --> 00:17:16,339
And these are all
the peripherals.

396
00:17:16,339 --> 00:17:20,030
The basic machine architecture--
at the heart of every computer

397
00:17:20,030 --> 00:17:25,280
there's just this
basic architecture--

398
00:17:25,280 --> 00:17:28,760
and it contains, I
guess, four main parts.

399
00:17:28,760 --> 00:17:31,550
The first is the memory.

400
00:17:31,550 --> 00:17:34,700
Input and output
is the other one.

401
00:17:34,700 --> 00:17:39,980
The ALU is where all of
the operations are done.

402
00:17:39,980 --> 00:17:41,570
And the operations
that the ALU can do

403
00:17:41,570 --> 00:17:44,570
are really primitive operations,
addition, subtraction,

404
00:17:44,570 --> 00:17:46,460
and so on.

405
00:17:46,460 --> 00:17:52,610
What the memory contains
is a bunch of data

406
00:17:52,610 --> 00:17:54,854
and your sequence
of instructions.

407
00:18:00,540 --> 00:18:03,870
Interacting with the Arithmetic
Logic Unit is the Control Unit.

408
00:18:03,870 --> 00:18:07,110
And the Control Unit
contains one program counter.

409
00:18:07,110 --> 00:18:09,900
When you load a sequence
of instructions,

410
00:18:09,900 --> 00:18:12,630
the program counter starts
at the first sequence.

411
00:18:15,540 --> 00:18:18,510
It starts at the sequence,
at the first instruction.

412
00:18:18,510 --> 00:18:22,200
It gets what the instruction
is, and it sends it to the ALU.

413
00:18:22,200 --> 00:18:25,990
The ALU asks, what are we
doing operations on here?

414
00:18:25,990 --> 00:18:27,330
What's happening?

415
00:18:27,330 --> 00:18:29,150
It might get some data.

416
00:18:29,150 --> 00:18:31,400
If you're adding two numbers,
it might get two numbers

417
00:18:31,400 --> 00:18:33,300
from memory.

418
00:18:33,300 --> 00:18:34,680
It might do some operations.

419
00:18:34,680 --> 00:18:37,650
And it might store
data back into memory.

420
00:18:37,650 --> 00:18:41,517
And after it's done, the
ALU is going to go back,

421
00:18:41,517 --> 00:18:43,350
and the program counter
is going to increase

422
00:18:43,350 --> 00:18:45,360
by 1, which means
that we're going

423
00:18:45,360 --> 00:18:50,200
to go to the next sequence
in the instruction set.

424
00:18:50,200 --> 00:18:53,840
And it just goes linearly,
instruction by instruction.

425
00:18:53,840 --> 00:18:56,330
There might be one
particular instruction

426
00:18:56,330 --> 00:18:58,100
that does some sort of test.

427
00:18:58,100 --> 00:19:07,040
It's going to say, is
this particular value

428
00:19:07,040 --> 00:19:11,330
greater or equal to or the same
as this other particular value?

429
00:19:11,330 --> 00:19:13,200
That's a test, an
example of a test.

430
00:19:13,200 --> 00:19:17,630
And the test is going to
either return true or false.

431
00:19:17,630 --> 00:19:20,810
And depending on the
result of that test,

432
00:19:20,810 --> 00:19:24,530
you might either go to
the next instruction,

433
00:19:24,530 --> 00:19:26,150
or you might set
the program counter

434
00:19:26,150 --> 00:19:29,810
to go all the way back to
the beginning, and so on.

435
00:19:29,810 --> 00:19:32,262
You're not just
linearly stepping

436
00:19:32,262 --> 00:19:33,470
through all the instructions.

437
00:19:33,470 --> 00:19:35,300
There might be some
control flow involved,

438
00:19:35,300 --> 00:19:36,800
where you might
skip an instruction,

439
00:19:36,800 --> 00:19:39,730
or start from the
beginning, or so on.

440
00:19:39,730 --> 00:19:42,410
And after you're done,
when you finished

441
00:19:42,410 --> 00:19:44,540
executing the last
instruction, then you

442
00:19:44,540 --> 00:19:47,180
might output something.

443
00:19:47,180 --> 00:19:53,420
That's really the basic
way that a computer works.

444
00:19:53,420 --> 00:19:55,790
Just to recap, you have
the stored program computer

445
00:19:55,790 --> 00:19:59,140
that contains these
sequences of instructions.

446
00:19:59,140 --> 00:20:00,950
The primitive operations
that it can do

447
00:20:00,950 --> 00:20:06,050
are addition, subtraction,
logic operations, tests--

448
00:20:06,050 --> 00:20:08,840
which are something equal
to something else, something

449
00:20:08,840 --> 00:20:10,790
less than, and so
on-- and moving data,

450
00:20:10,790 --> 00:20:14,390
so storing data, moving data
around, and things like that.

451
00:20:14,390 --> 00:20:19,836
And the interpreter goes
through every instruction

452
00:20:19,836 --> 00:20:22,460
and decides whether you're going
to go to the next instruction,

453
00:20:22,460 --> 00:20:28,830
skip instructions, or repeat
instructions, and so on.

454
00:20:28,830 --> 00:20:30,570
So we've talked
about primitives.

455
00:20:30,570 --> 00:20:35,267
And in fact, Alan Turing, who
was a really great computer

456
00:20:35,267 --> 00:20:37,350
scientist, he showed that
you can compute anything

457
00:20:37,350 --> 00:20:38,880
using the six primitives.

458
00:20:38,880 --> 00:20:46,590
And the six primitives are move
left, move right, read, write,

459
00:20:46,590 --> 00:20:49,050
scan, and do nothing.

460
00:20:49,050 --> 00:20:54,390
Using those six instructions
and the piece of tape,

461
00:20:54,390 --> 00:20:57,330
he showed that you
can compute anything.

462
00:20:57,330 --> 00:21:00,390
And using those
six instructions,

463
00:21:00,390 --> 00:21:03,090
programming languages
came about that

464
00:21:03,090 --> 00:21:05,100
created a more convenient
set of primitives.

465
00:21:05,100 --> 00:21:08,520
You don't have to program
in only these six commands.

466
00:21:11,490 --> 00:21:16,080
And one interesting thing, or
one really important thing,

467
00:21:16,080 --> 00:21:19,230
that came about from
these six primitives

468
00:21:19,230 --> 00:21:22,290
is that if you can compute
something in Python,

469
00:21:22,290 --> 00:21:25,770
let's say-- if you write a
program that computes something

470
00:21:25,770 --> 00:21:28,950
in Python, then,
in theory, you can

471
00:21:28,950 --> 00:21:31,260
write a program that
computes the exact same thing

472
00:21:31,260 --> 00:21:32,610
in any other language.

473
00:21:32,610 --> 00:21:36,720
And that's a really
powerful statement.

474
00:21:36,720 --> 00:21:39,660
Think about that today when
you review your slides.

475
00:21:39,660 --> 00:21:40,860
Think about that again.

476
00:21:40,860 --> 00:21:41,910
That's really powerful.

477
00:21:45,240 --> 00:21:49,980
Once you have your
set of primitives

478
00:21:49,980 --> 00:21:53,839
for a particular language, you
can start creating expressions.

479
00:21:53,839 --> 00:21:55,380
And these expressions
are going to be

480
00:21:55,380 --> 00:22:00,510
combinations of the primitives
in the programming language.

481
00:22:00,510 --> 00:22:02,790
And the expressions are
going to have some value.

482
00:22:02,790 --> 00:22:05,740
And they're going up some
meaning in the programming

483
00:22:05,740 --> 00:22:08,440
language.

484
00:22:08,440 --> 00:22:10,630
Let's do a little bit of
a parallel with English

485
00:22:10,630 --> 00:22:14,020
just so you see what I mean.

486
00:22:14,020 --> 00:22:15,520
In English, the
primitive constructs

487
00:22:15,520 --> 00:22:17,230
are going to be words.

488
00:22:17,230 --> 00:22:19,190
There's a lot of words
in the English language.

489
00:22:19,190 --> 00:22:23,230
Programming languages-- in
Python, there are primitives,

490
00:22:23,230 --> 00:22:25,110
but there aren't
as many of them.

491
00:22:25,110 --> 00:22:28,900
There are floats,
Booleans, these

492
00:22:28,900 --> 00:22:31,660
are numbers, strings,
and simple operators,

493
00:22:31,660 --> 00:22:35,170
like addition,
subtraction, and so on.

494
00:22:35,170 --> 00:22:38,230
So we have primitive constructs.

495
00:22:38,230 --> 00:22:39,820
Using these
primitive constructs,

496
00:22:39,820 --> 00:22:48,167
we can start creating, in
English, phrases, sentences,

497
00:22:48,167 --> 00:22:49,750
and the same in
programming languages.

498
00:22:49,750 --> 00:22:54,370
In English, we can say
something like, "cat, dog, boy.

499
00:22:54,370 --> 00:22:58,360
That, we say, is not
syntactically valid.

500
00:22:58,360 --> 00:23:00,170
That's bad syntax.

501
00:23:00,170 --> 00:23:01,920
That's noun, noun, noun.

502
00:23:01,920 --> 00:23:05,160
That doesn't make sense.

503
00:23:05,160 --> 00:23:08,940
What does have good syntax in
English is noun, verb, noun.

504
00:23:08,940 --> 00:23:12,790
So, "cat, hugs boy" is
syntactically valid.

505
00:23:12,790 --> 00:23:14,680
Similarly, in a
programming language,

506
00:23:14,680 --> 00:23:18,195
something like this-- in
Python, in this case-- a word

507
00:23:18,195 --> 00:23:20,320
and then the number five
doesn't really make sense.

508
00:23:20,320 --> 00:23:22,000
It's not syntactically valid.

509
00:23:22,000 --> 00:23:28,030
But something like operator,
operand, operator is OK.

510
00:23:28,030 --> 00:23:34,480
So once you've created these
phrases, or these expressions,

511
00:23:34,480 --> 00:23:37,240
that are syntactically
valid, you

512
00:23:37,240 --> 00:23:41,730
have to think about the static
semantics of your phrase,

513
00:23:41,730 --> 00:23:45,130
or of your expression.

514
00:23:45,130 --> 00:23:51,280
For example, in English, "I
are hungry" is good syntax.

515
00:23:51,280 --> 00:23:55,330
But it's weird to say.

516
00:23:55,330 --> 00:23:58,270
We have a pronoun, a verb,
and an adjective, which

517
00:23:58,270 --> 00:23:59,770
doesn't really make sense.

518
00:23:59,770 --> 00:24:03,490
"I am hungry" is better.

519
00:24:03,490 --> 00:24:07,270
This does not have
good static semantics.

520
00:24:07,270 --> 00:24:09,010
Similarly, in
programming languages--

521
00:24:09,010 --> 00:24:11,440
and you'll get the
hang of this the more

522
00:24:11,440 --> 00:24:15,950
you do it-- something like
this, "3.2 times 5, is OK.

523
00:24:15,950 --> 00:24:17,390
But what does it mean?

524
00:24:17,390 --> 00:24:22,330
What's the meaning to have
a word added to a number?

525
00:24:22,330 --> 00:24:25,660
There's no meaning behind that.

526
00:24:25,660 --> 00:24:28,030
Its syntax is OK,
because you have

527
00:24:28,030 --> 00:24:30,120
operator, operand, operator.

528
00:24:30,120 --> 00:24:32,770
But it doesn't really make
sense to add a number to a word,

529
00:24:32,770 --> 00:24:33,300
for example.

530
00:24:36,640 --> 00:24:39,970
Once you have created
these expressions that

531
00:24:39,970 --> 00:24:44,940
are syntactically correct and
static, semantically correct,

532
00:24:44,940 --> 00:24:48,940
in English, for example, you
think about the semantics.

533
00:24:48,940 --> 00:24:50,760
What's the meaning
of the phrase?

534
00:24:50,760 --> 00:24:52,780
In English, you can
actually have more than one

535
00:24:52,780 --> 00:24:56,140
meaning to an entire phrase.

536
00:24:56,140 --> 00:25:01,284
In this case, "flying
planes can be dangerous"

537
00:25:01,284 --> 00:25:02,200
can have two meanings.

538
00:25:02,200 --> 00:25:04,990
It's the act of flying
a plane is dangerous,

539
00:25:04,990 --> 00:25:08,860
or the plane that is in
the air is dangerous.

540
00:25:08,860 --> 00:25:10,650
And this might be
a cuter example.

541
00:25:10,650 --> 00:25:12,490
"This reading lamp
hasn't uttered a word

542
00:25:12,490 --> 00:25:13,690
since I bought it.

543
00:25:13,690 --> 00:25:15,160
What's going on?"

544
00:25:15,160 --> 00:25:16,380
So that has two meanings.

545
00:25:16,380 --> 00:25:21,130
It's playing on the
word "reading lamp."

546
00:25:21,130 --> 00:25:21,880
That's in English.

547
00:25:21,880 --> 00:25:23,338
In English, you
can have a sentence

548
00:25:23,338 --> 00:25:25,140
that has more than
one meaning, that's

549
00:25:25,140 --> 00:25:28,150
syntactically correct and
static, semantically correct.

550
00:25:28,150 --> 00:25:31,180
But in programming languages,
the program that you write,

551
00:25:31,180 --> 00:25:34,085
the set of instructions that
you write, only has one meaning.

552
00:25:34,085 --> 00:25:35,710
Remember, we're coming
back to the fact

553
00:25:35,710 --> 00:25:40,120
that the computer only does
what you tell it to do.

554
00:25:40,120 --> 00:25:42,250
It's not going to
suddenly decide

555
00:25:42,250 --> 00:25:46,390
to add another variable
for some reason.

556
00:25:46,390 --> 00:25:49,060
It's just going to execute
whatever statements you've

557
00:25:49,060 --> 00:25:50,715
put up.

558
00:25:50,715 --> 00:25:52,840
In programming languages,
there's only one meaning.

559
00:25:52,840 --> 00:25:58,099
But the problem that comes into
play in programming languages

560
00:25:58,099 --> 00:25:59,890
is it's not the meaning
that you might have

561
00:25:59,890 --> 00:26:03,130
intended, as the programmer.

562
00:26:03,130 --> 00:26:05,926
That's where things
can go wrong.

563
00:26:05,926 --> 00:26:07,300
And there's going
to be a lecture

564
00:26:07,300 --> 00:26:10,010
on debugging a little
bit later in the course.

565
00:26:10,010 --> 00:26:12,880
But this is here
just to tell you

566
00:26:12,880 --> 00:26:16,090
that if you see an error
pop up in your program,

567
00:26:16,090 --> 00:26:18,410
it's just some text
that says, error.

568
00:26:21,160 --> 00:26:28,330
For example, if we do
something like this,

569
00:26:28,330 --> 00:26:30,900
this is syntactically correct.

570
00:26:30,900 --> 00:26:31,400
Incorrect.

571
00:26:31,400 --> 00:26:32,230
Syntactically incorrect.

572
00:26:32,230 --> 00:26:32,730
See?

573
00:26:32,730 --> 00:26:36,050
There's some angry
text right here.

574
00:26:36,050 --> 00:26:37,719
What is going on?

575
00:26:37,719 --> 00:26:39,260
The more you program,
the more you'll

576
00:26:39,260 --> 00:26:41,210
get the hang of
reading these errors.

577
00:26:41,210 --> 00:26:43,550
But this is basically
telling me the line

578
00:26:43,550 --> 00:26:45,890
that I wrote is
syntactically incorrect.

579
00:26:45,890 --> 00:26:49,190
And it's pointing to the exact
line and says, this is wrong,

580
00:26:49,190 --> 00:26:52,450
so I can go back and
fix it as a programmer.

581
00:26:55,480 --> 00:26:57,905
Syntax errors are actually
really easily caught by Python.

582
00:27:00,800 --> 00:27:02,870
That was an example
of a syntax error.

583
00:27:02,870 --> 00:27:04,640
Static semantic
errors can also be

584
00:27:04,640 --> 00:27:09,830
caught by Python as long as, if
your program has some decisions

585
00:27:09,830 --> 00:27:13,970
to make, as long as you've
gone down the branch where

586
00:27:13,970 --> 00:27:18,080
the static semantic
error happens.

587
00:27:18,080 --> 00:27:22,160
And this is probably going to
be the most frustrating one,

588
00:27:22,160 --> 00:27:23,767
especially as
you're starting out.

589
00:27:23,767 --> 00:27:25,850
The program might do
something different than what

590
00:27:25,850 --> 00:27:27,740
you expected it to do.

591
00:27:27,740 --> 00:27:32,300
And that's not because the
program suddenly-- for example,

592
00:27:32,300 --> 00:27:34,460
you expected the program
to give you an output of 0

593
00:27:34,460 --> 00:27:37,826
for a certain test case, and
the output that you got was 10.

594
00:27:37,826 --> 00:27:39,200
Well, the program
didn't suddenly

595
00:27:39,200 --> 00:27:42,350
decide to change
its answer to 10.

596
00:27:42,350 --> 00:27:45,410
It just executed the
program that you wrote.

597
00:27:48,710 --> 00:27:50,660
That's the case where
the program gave you

598
00:27:50,660 --> 00:27:53,210
a different answer
than expected.

599
00:27:53,210 --> 00:27:55,580
Programs might crash, which
means they stop running.

600
00:27:55,580 --> 00:27:57,800
That's OK.

601
00:27:57,800 --> 00:28:00,440
Just go back to your code and
figure out what was wrong.

602
00:28:00,440 --> 00:28:03,650
And another example
of a different meaning

603
00:28:03,650 --> 00:28:06,790
than what you intended was
maybe the program won't stop.

604
00:28:06,790 --> 00:28:07,580
It's also OK.

605
00:28:07,580 --> 00:28:10,070
There are ways to stop
it besides restarting

606
00:28:10,070 --> 00:28:12,950
the computer.

607
00:28:12,950 --> 00:28:17,770
So then Python
programs are going

608
00:28:17,770 --> 00:28:20,260
to be sequences of
definitions and commands.

609
00:28:20,260 --> 00:28:25,090
We're going to have expressions
that are going to be evaluated

610
00:28:25,090 --> 00:28:33,820
and commands that tell the
interpreter to do something.

611
00:28:33,820 --> 00:28:35,410
If you've done
problem set 0, you'll

612
00:28:35,410 --> 00:28:37,930
see that you can type
commands directly

613
00:28:37,930 --> 00:28:40,720
in the shell here, which is
the part on the right where

614
00:28:40,720 --> 00:28:44,500
I did some really
simple things, 2 plus 4.

615
00:28:44,500 --> 00:28:49,480
Or you can type commands up in
here, on the left-hand side,

616
00:28:49,480 --> 00:28:52,100
and then run your program.

617
00:28:52,100 --> 00:28:54,907
Notice that, well, we'll
talk about this-- I

618
00:28:54,907 --> 00:28:55,990
won't talk about this now.

619
00:28:55,990 --> 00:28:59,920
But these are-- on the
right-hand side, typically,

620
00:28:59,920 --> 00:29:01,870
you write very simple
commands just if you're

621
00:29:01,870 --> 00:29:03,076
testing something out.

622
00:29:03,076 --> 00:29:04,950
And on the left-hand
side here in the editor,

623
00:29:04,950 --> 00:29:10,105
you write more lines and
more complicated programs.

624
00:29:15,130 --> 00:29:18,700
Now we're going to start
talking about Python.

625
00:29:18,700 --> 00:29:20,710
And in Python, we're going
to come back to this,

626
00:29:20,710 --> 00:29:23,530
everything is an object.

627
00:29:23,530 --> 00:29:27,910
And Python programs
manipulate these data objects.

628
00:29:27,910 --> 00:29:30,880
All objects in Python
are going to have a type.

629
00:29:30,880 --> 00:29:34,000
And the type is going to tell
Python the kinds of operations

630
00:29:34,000 --> 00:29:37,630
that you can do
on these objects.

631
00:29:37,630 --> 00:29:39,950
If an object is the
number five, for example,

632
00:29:39,950 --> 00:29:42,749
you can add the number
to another number,

633
00:29:42,749 --> 00:29:45,040
subtract the number, take it
to the power of something,

634
00:29:45,040 --> 00:29:47,260
and so on.

635
00:29:47,260 --> 00:29:51,520
As a more general example,
for example, I am a human.

636
00:29:51,520 --> 00:29:52,930
So that's my type.

637
00:29:52,930 --> 00:29:55,700
And I can walk, speak
English, et cetera.

638
00:29:55,700 --> 00:29:59,860
Chewbacca is going
to be a type Wookie.

639
00:29:59,860 --> 00:30:02,834
He can walk, do that
sound that I can't do.

640
00:30:02,834 --> 00:30:04,000
He can do that, but I can't.

641
00:30:04,000 --> 00:30:06,683
I'm not even going
to try, and so on.

642
00:30:09,640 --> 00:30:11,200
Once you have these
Python objects,

643
00:30:11,200 --> 00:30:14,934
everything is an
object in Python.

644
00:30:14,934 --> 00:30:16,600
There are actually
two types of objects.

645
00:30:16,600 --> 00:30:18,100
One are scalar objects.

646
00:30:18,100 --> 00:30:21,370
That means these are very basic
objects in Python from which

647
00:30:21,370 --> 00:30:24,760
everything can be made.

648
00:30:24,760 --> 00:30:26,050
These are scalar objects.

649
00:30:26,050 --> 00:30:28,480
That can't be subdivided.

650
00:30:28,480 --> 00:30:31,210
The other type of object
is a non-scalar object.

651
00:30:31,210 --> 00:30:33,700
And these are objects that
have some internal structure.

652
00:30:33,700 --> 00:30:36,730
For example, the
number five is a scalar

653
00:30:36,730 --> 00:30:39,070
object because it
can't be subdivided.

654
00:30:39,070 --> 00:30:41,710
But a list of numbers,
for example, 5, 6,

655
00:30:41,710 --> 00:30:45,370
7,8, is going to be
a non-scalar object

656
00:30:45,370 --> 00:30:46,600
because you can subdivide it.

657
00:30:46,600 --> 00:30:53,120
You can subdivide it into--
you can find parts to it.

658
00:30:53,120 --> 00:30:55,130
It's made up of a
sequence of numbers.

659
00:30:58,700 --> 00:31:01,220
Here's the list of all of
the scalar objects in Python.

660
00:31:01,220 --> 00:31:05,870
We have integers, for example,
all of the whole numbers.

661
00:31:05,870 --> 00:31:10,130
Floats, which are all of
the real numbers, anything

662
00:31:10,130 --> 00:31:11,510
with a decimal.

663
00:31:11,510 --> 00:31:13,760
Bools are Booleans.

664
00:31:13,760 --> 00:31:16,100
There's only two
values to Booleans.

665
00:31:16,100 --> 00:31:18,500
That's True and False.

666
00:31:18,500 --> 00:31:23,060
Note the capitalization,
capital T and capital F.

667
00:31:23,060 --> 00:31:24,805
And this other thing
called NoneType.

668
00:31:24,805 --> 00:31:26,510
It's special.

669
00:31:26,510 --> 00:31:28,590
It has only one
value called None.

670
00:31:28,590 --> 00:31:30,500
And it represents the
absence of a type.

671
00:31:30,500 --> 00:31:34,640
And it sometimes comes in
handy for some programs.

672
00:31:34,640 --> 00:31:36,390
If you want to find
the type of an object,

673
00:31:36,390 --> 00:31:39,532
you can use this special
command called type.

674
00:31:39,532 --> 00:31:41,240
And then in the
parentheses, you put down

675
00:31:41,240 --> 00:31:44,840
what you want to
find the type of.

676
00:31:44,840 --> 00:31:47,480
You can write into
the shell "type of 5,"

677
00:31:47,480 --> 00:31:49,566
and the shell will tell
you, that's an integer.

678
00:31:52,990 --> 00:31:56,290
If you happen to want to convert
between two different types,

679
00:31:56,290 --> 00:31:58,180
Python allows you to do that.

680
00:31:58,180 --> 00:32:01,450
And to do that, you
put the type that you

681
00:32:01,450 --> 00:32:03,820
want to convert to
right before the object

682
00:32:03,820 --> 00:32:05,270
that you want to convert to.

683
00:32:05,270 --> 00:32:12,700
So float(3) will convert the
integer 3 to the float 3.0.

684
00:32:12,700 --> 00:32:16,870
And similarly, you can convert
any float into an integer.

685
00:32:16,870 --> 00:32:20,170
And converting to an
integer just truncates.

686
00:32:20,170 --> 00:32:22,180
It just takes away the
decimal and whatever's

687
00:32:22,180 --> 00:32:26,150
after it-- it does not round--
and keeps just the integer

688
00:32:26,150 --> 00:32:26,650
part.

689
00:32:30,119 --> 00:32:31,910
For this slide, I'm
going to talk about it.

690
00:32:31,910 --> 00:32:35,060
But if you'd like if
you have the slides up,

691
00:32:35,060 --> 00:32:37,200
go to go to this exercise.

692
00:32:37,200 --> 00:32:41,000
And after I'm done
talking about the slide,

693
00:32:41,000 --> 00:32:45,532
we'll see what people
think for that exercise.

694
00:32:45,532 --> 00:32:47,240
One of the most
important things that you

695
00:32:47,240 --> 00:32:51,280
can do in basically
any programming,

696
00:32:51,280 --> 00:32:55,520
in Python also, is
to print things out.

697
00:32:55,520 --> 00:33:00,292
Printing out is how you
interact with the user.

698
00:33:00,292 --> 00:33:02,250
To print things out, you
use the print command.

699
00:33:04,850 --> 00:33:07,560
If you're in the shell, if
you simply type "3 plus 2,"

700
00:33:07,560 --> 00:33:09,700
you do see a value here.

701
00:33:09,700 --> 00:33:11,720
Five, right?

702
00:33:11,720 --> 00:33:13,850
But that's not actually
printing something out.

703
00:33:13,850 --> 00:33:18,380
And that becomes apparent
when you actually

704
00:33:18,380 --> 00:33:19,640
type things into the editor.

705
00:33:19,640 --> 00:33:23,160
If you just do "3 plus 2," and
you run the program-- that's

706
00:33:23,160 --> 00:33:26,270
the green button here-- you see
on the right-hand side here,

707
00:33:26,270 --> 00:33:27,080
it ran my program.

708
00:33:27,080 --> 00:33:30,200
But it didn't actually
print anything.

709
00:33:30,200 --> 00:33:32,150
If you type this
into the console,

710
00:33:32,150 --> 00:33:33,920
it does show you this
value, but that's

711
00:33:33,920 --> 00:33:39,470
just like peeking into the
value for you as a programmer.

712
00:33:39,470 --> 00:33:41,412
It's not actually
printing it out to anyone.

713
00:33:41,412 --> 00:33:42,870
If you want to
print something out,

714
00:33:42,870 --> 00:33:47,990
you have to use the print
statement like that.

715
00:33:47,990 --> 00:33:50,630
In this case, this is actually
going to print this number

716
00:33:50,630 --> 00:33:52,290
five to the console.

717
00:33:58,296 --> 00:33:59,545
That's basically what it says.

718
00:33:59,545 --> 00:34:01,794
It just tells you it's an
interaction within the shell

719
00:34:01,794 --> 00:34:02,410
only.

720
00:34:02,410 --> 00:34:04,529
It's not interacting
with anyone else.

721
00:34:04,529 --> 00:34:06,070
And if you don't
have any "Out," that

722
00:34:06,070 --> 00:34:09,489
means it got printed
out to the console.

723
00:34:09,489 --> 00:34:09,989
All right.

724
00:34:09,989 --> 00:34:13,320
We talked a little
bit about objects.

725
00:34:13,320 --> 00:34:16,050
Once you have objects, you can
combine objects and operators

726
00:34:16,050 --> 00:34:17,170
to form these expressions.

727
00:34:17,170 --> 00:34:19,440
And each expression is
going to have a value.

728
00:34:19,440 --> 00:34:22,949
So an expression
evaluates to a value.

729
00:34:22,949 --> 00:34:24,600
The syntax for an
expression is going

730
00:34:24,600 --> 00:34:30,449
to be object, operator,
object, like that.

731
00:34:30,449 --> 00:34:34,409
And these are some operators
you can do on ints and floats.

732
00:34:34,409 --> 00:34:36,580
There's the typical ones,
addition, subtraction,

733
00:34:36,580 --> 00:34:38,710
multiplication, and division.

734
00:34:38,710 --> 00:34:43,104
If, for the first
three, the answer

735
00:34:43,104 --> 00:34:45,270
that you get-- the type of
the answer that you get--

736
00:34:45,270 --> 00:34:48,480
is going to depend on the
type of your variables.

737
00:34:48,480 --> 00:34:52,769
If both of the variables of
the operands are integers,

738
00:34:52,769 --> 00:34:55,060
then the result you're going
to get is of type integer.

739
00:34:55,060 --> 00:34:56,893
But if at least one of
them is a float, then

740
00:34:56,893 --> 00:34:58,940
the result you're going
to get is a float.

741
00:34:58,940 --> 00:35:02,340
Division is a little
bit special in that

742
00:35:02,340 --> 00:35:04,690
no matter what the
operands are, the result

743
00:35:04,690 --> 00:35:05,940
is always going to be a float.

744
00:35:09,760 --> 00:35:14,480
The other operations you can
do, and these are also useful,

745
00:35:14,480 --> 00:35:19,140
are the remainder,
so the percent sign.

746
00:35:19,140 --> 00:35:22,960
If you use the percent
sign between two operands,

747
00:35:22,960 --> 00:35:25,540
that's going to give you the
remainder when you divide i

748
00:35:25,540 --> 00:35:28,024
by j.

749
00:35:28,024 --> 00:35:30,190
And raising something to
the power of something else

750
00:35:30,190 --> 00:35:32,770
is using the star star operator.

751
00:35:32,770 --> 00:35:36,050
And i star stars j is going
to take i to the power of j.

752
00:35:41,390 --> 00:35:43,940
These operations have
the typical precedence

753
00:35:43,940 --> 00:35:47,060
that you might expect
in math, for example.

754
00:35:47,060 --> 00:35:49,075
And if you'd like
to put precedence

755
00:35:49,075 --> 00:35:50,450
toward some other
operations, you

756
00:35:50,450 --> 00:35:52,270
can use parentheses to do that.

757
00:36:01,490 --> 00:36:03,990
All right.

758
00:36:03,990 --> 00:36:07,050
So we have ways of
creating expressions.

759
00:36:07,050 --> 00:36:13,500
And we have operations
we can do on objects.

760
00:36:13,500 --> 00:36:19,140
But what's going to be useful
is to be able to save values

761
00:36:19,140 --> 00:36:21,390
to some name.

762
00:36:21,390 --> 00:36:24,780
And the name is going to
be something that you pick.

763
00:36:24,780 --> 00:36:27,840
And it should be a
descriptive name.

764
00:36:27,840 --> 00:36:32,310
And when you save
the value to a name,

765
00:36:32,310 --> 00:36:36,030
you're going to be able
to access that value later

766
00:36:36,030 --> 00:36:37,950
on in your program.

767
00:36:37,950 --> 00:36:40,440
And that's very useful.

768
00:36:40,440 --> 00:36:45,270
To save a value to a variable
name, you use the equal sign.

769
00:36:49,180 --> 00:36:51,520
And the equal sign
is an assignment.

770
00:36:51,520 --> 00:36:53,080
It assigns the
right-hand side, which

771
00:36:53,080 --> 00:36:55,540
is a value, to the
left-hand side, which

772
00:36:55,540 --> 00:36:56,898
is going to be a variable name.

773
00:36:59,500 --> 00:37:03,000
In this case, I assigned
the float 3.14159

774
00:37:03,000 --> 00:37:05,590
to the variable pi.

775
00:37:05,590 --> 00:37:08,200
And in the second
line, I'm going

776
00:37:08,200 --> 00:37:10,750
to take this expression,
22 divided by 7,

777
00:37:10,750 --> 00:37:13,090
I'm going to evaluate it.

778
00:37:13,090 --> 00:37:16,060
It's going to come up
with some decimal number.

779
00:37:16,060 --> 00:37:19,960
And I'm going to save it
into the variable pi_approx.

780
00:37:19,960 --> 00:37:21,520
values are stored in memory.

781
00:37:21,520 --> 00:37:22,960
And this assignment
in Python, we

782
00:37:22,960 --> 00:37:26,950
say the assignment binds
the name to the value.

783
00:37:26,950 --> 00:37:30,850
When you use that name
later on in your program,

784
00:37:30,850 --> 00:37:35,650
you're going to be referring
to the value in memory.

785
00:37:35,650 --> 00:37:37,879
And if you ever want
to refer to the value

786
00:37:37,879 --> 00:37:39,670
later on in your code,
you just simply type

787
00:37:39,670 --> 00:37:44,470
the name of the variable
that you've assigned it to.

788
00:37:44,470 --> 00:37:48,250
So why do we want to give
names to expressions?

789
00:37:48,250 --> 00:37:51,670
Well, you want to reuse the
names instead of the values.

790
00:37:51,670 --> 00:37:54,340
And it makes your
code look a lot nicer.

791
00:37:54,340 --> 00:37:56,830
This is a piece of
code that calculates

792
00:37:56,830 --> 00:37:59,390
the area of a circle.

793
00:37:59,390 --> 00:38:03,110
And notice, I've assigned
a variable pi to 3.14159.

794
00:38:03,110 --> 00:38:07,360
I've assigned another variable
called radius to be 2.2.

795
00:38:07,360 --> 00:38:09,700
And then, later on in my
code, I have another line

796
00:38:09,700 --> 00:38:12,940
that says area-- this
is another variable-- is

797
00:38:12,940 --> 00:38:15,400
equal to-- this
is an assignment--

798
00:38:15,400 --> 00:38:17,290
to this expression.

799
00:38:17,290 --> 00:38:23,080
And this expression is referring
to these variable names, pi

800
00:38:23,080 --> 00:38:24,490
and radius.

801
00:38:24,490 --> 00:38:26,410
And it's going look up
their values in memory.

802
00:38:26,410 --> 00:38:29,080
And it's going to replace
these variable names

803
00:38:29,080 --> 00:38:30,100
with those values.

804
00:38:30,100 --> 00:38:32,850
And it's going to do
the calculation for me.

805
00:38:32,850 --> 00:38:34,450
And in the end, this
whole expression

806
00:38:34,450 --> 00:38:36,402
is going to be
replaced by one number.

807
00:38:36,402 --> 00:38:37,693
And it's going to be the float.

808
00:38:40,420 --> 00:38:45,280
Here's another exercise, while
I'm talking about the slide.

809
00:38:45,280 --> 00:38:49,090
I do want to make a note
about programming versus math.

810
00:38:49,090 --> 00:38:55,320
In math, you're often
presented with a problem

811
00:38:55,320 --> 00:38:57,580
that says, solve for x.

812
00:38:57,580 --> 00:39:00,260
x plus y is equal to
something something.

813
00:39:00,260 --> 00:39:03,760
Solve for x, for example.

814
00:39:03,760 --> 00:39:09,550
That's coming back to the
fact that computers don't

815
00:39:09,550 --> 00:39:10,720
know what to do with that.

816
00:39:10,720 --> 00:39:12,659
Computers need to
be told what to do.

817
00:39:12,659 --> 00:39:14,450
In programming, if you
want to solve for x,

818
00:39:14,450 --> 00:39:18,530
you need to tell the computer
exactly how to solve for x.

819
00:39:18,530 --> 00:39:20,350
You need to figure
out what formula

820
00:39:20,350 --> 00:39:22,900
you need to give the
computer in order to be

821
00:39:22,900 --> 00:39:25,690
able to solve for x.

822
00:39:25,690 --> 00:39:29,530
That means always in programming
the right-hand side is

823
00:39:29,530 --> 00:39:33,040
going to be an expression.

824
00:39:33,040 --> 00:39:35,980
It's something that's going
to be evaluated to a value.

825
00:39:35,980 --> 00:39:39,099
And the left-hand side
is always a variable.

826
00:39:39,099 --> 00:39:40,390
It's going to be an assignment.

827
00:39:40,390 --> 00:39:43,900
The equal sign is
not like in math

828
00:39:43,900 --> 00:39:45,820
where you can have a lot
of things to the left

829
00:39:45,820 --> 00:39:47,380
and a lot of things to the
right of the equal sign.

830
00:39:47,380 --> 00:39:49,060
There's only one thing to
the left of the equal sign.

831
00:39:49,060 --> 00:39:50,770
And that's going
to be a variable.

832
00:39:50,770 --> 00:39:53,710
An equal sign stands
for an assignment.

833
00:39:53,710 --> 00:39:57,130
Once we've created expressions,
and we have these assignments,

834
00:39:57,130 --> 00:39:59,470
you can rebind variable
names using new assignment

835
00:39:59,470 --> 00:40:00,250
statements.

836
00:40:03,160 --> 00:40:05,020
Let's look at an
example for that.

837
00:40:05,020 --> 00:40:07,840
Let's say this is our memory.

838
00:40:07,840 --> 00:40:13,420
Let's type back in the example
with finding the radius.

839
00:40:13,420 --> 00:40:19,030
Let's say, pi is equal to 3.14.

840
00:40:19,030 --> 00:40:22,210
In memory, we're going to
create this value 3.14.

841
00:40:22,210 --> 00:40:28,180
We're going to bind it
to the variable named pi.

842
00:40:28,180 --> 00:40:31,180
Next line, radius
is equal to 2.2.

843
00:40:31,180 --> 00:40:35,200
In memory, we're
creating this value 2.2.

844
00:40:35,200 --> 00:40:40,630
And we're going to bind it
to the variable named radius.

845
00:40:40,630 --> 00:40:44,590
Then we have this
expression here.

846
00:40:44,590 --> 00:40:46,630
It's going to substitute
the values for pi

847
00:40:46,630 --> 00:40:49,950
from memory and the value
for radius from memory.

848
00:40:49,950 --> 00:40:54,730
It's going to calculate the
value that this expression

849
00:40:54,730 --> 00:40:56,310
evaluates to.

850
00:40:56,310 --> 00:40:57,940
It's going to pop
that into the memory.

851
00:40:57,940 --> 00:40:59,925
And it's going to
assign-- because we're

852
00:40:59,925 --> 00:41:01,300
using the equal
sign-- it's going

853
00:41:01,300 --> 00:41:05,630
to assign that value
to that variable area.

854
00:41:08,310 --> 00:41:14,940
Now, let's say we rebind
radius to be something else.

855
00:41:14,940 --> 00:41:21,540
Radius i is bound
to the value 2.2.

856
00:41:21,540 --> 00:41:24,540
But when we do this line, radius
is equal to radius plus 1,

857
00:41:24,540 --> 00:41:27,600
we're going to take
away the binding to 2.2.

858
00:41:27,600 --> 00:41:29,970
We're going to do
this calculation.

859
00:41:29,970 --> 00:41:31,320
The new value is 3.2.

860
00:41:31,320 --> 00:41:38,070
And we're going to rebind that
value to that same variable.

861
00:41:38,070 --> 00:41:40,110
In memory, notice
we're still going

862
00:41:40,110 --> 00:41:43,860
to have this value,
2.2, floating around.

863
00:41:43,860 --> 00:41:46,770
But we've lost
the handle for it.

864
00:41:46,770 --> 00:41:48,060
There's no way to get it back.

865
00:41:48,060 --> 00:41:52,050
It's just in memory
sitting there.

866
00:41:52,050 --> 00:41:55,080
At some point, it might
get collected by what

867
00:41:55,080 --> 00:41:56,550
we call the garbage collector.

868
00:41:56,550 --> 00:42:00,960
In Python, And it'll
retrieve these lost values,

869
00:42:00,960 --> 00:42:05,910
and it'll reuse them for new
values, and things like that.

870
00:42:05,910 --> 00:42:08,520
But radius now points
to the new value.

871
00:42:08,520 --> 00:42:13,800
We can never get back 2.2.

872
00:42:13,800 --> 00:42:16,340
And that's it.

873
00:42:16,340 --> 00:42:18,980
The value of area-- notice,
this is very important.

874
00:42:18,980 --> 00:42:20,450
The value of area
did not change.

875
00:42:23,150 --> 00:42:26,000
And it did not change because
these are all the instructions

876
00:42:26,000 --> 00:42:28,460
we told the computer to do.

877
00:42:28,460 --> 00:42:33,290
We just told it to change
radius to be radius plus 1.

878
00:42:33,290 --> 00:42:37,490
We never told it to
recalculate the value of area.

879
00:42:37,490 --> 00:42:41,600
If I copied that line down
here, then the value of area

880
00:42:41,600 --> 00:42:42,830
would change.

881
00:42:42,830 --> 00:42:44,430
But we never told it to do that.

882
00:42:44,430 --> 00:42:46,954
The computer only does
what we tell it to do.

883
00:42:46,954 --> 00:42:47,870
That's the last thing.

884
00:42:47,870 --> 00:42:51,150
Next lecture, we're going
to talk about adding control

885
00:42:51,150 --> 00:42:53,570
flow to our programs, so
how do you tell the computer

886
00:42:53,570 --> 00:42:55,550
to do one thing or another?

887
00:42:55,550 --> 00:42:57,160
All right.